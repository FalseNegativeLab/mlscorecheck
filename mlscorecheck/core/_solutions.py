"""
This module is generated by the notebook notebook/utils/001_generate_python.ipynb
"""

import numpy as np

from ._scores import sqrt, reduce_solutions

__all__ = [  'solve_acc_sens',
  'solve_acc_spec',
  'solve_acc_npv',
  'solve_acc_ppv',
  'solve_acc_f1_plus',
  'solve_acc_f1_minus',
  '_solve_acc_fm_0',
  '_solve_acc_fm_1',
  'solve_acc_fm',
  'solve_acc_bm',
  '_solve_acc_pt_0',
  '_solve_acc_pt_1',
  'solve_acc_pt',
  'solve_acc_lrp',
  'solve_acc_lrn',
  '_solve_acc_mk_0',
  '_solve_acc_mk_1',
  'solve_acc_mk',
  '_solve_acc_dor_0',
  '_solve_acc_dor_1',
  'solve_acc_dor',
  '_solve_acc_mcc_0',
  '_solve_acc_mcc_1',
  'solve_acc_mcc',
  'solve_acc_ji',
  'solve_acc_ba',
  'solve_sens_spec',
  'solve_sens_npv',
  'solve_sens_ppv',
  'solve_sens_f1_plus',
  'solve_sens_f1_minus',
  'solve_sens_fm',
  'solve_sens_bm',
  '_solve_sens_pt_0',
  '_solve_sens_pt_1',
  'solve_sens_pt',
  'solve_sens_lrp',
  'solve_sens_lrn',
  '_solve_sens_mk_0',
  '_solve_sens_mk_1',
  'solve_sens_mk',
  'solve_sens_dor',
  '_solve_sens_mcc_0',
  '_solve_sens_mcc_1',
  'solve_sens_mcc',
  'solve_sens_ji',
  'solve_sens_ba',
  'solve_spec_npv',
  'solve_spec_ppv',
  'solve_spec_f1_plus',
  'solve_spec_f1_minus',
  '_solve_spec_fm_0',
  '_solve_spec_fm_1',
  'solve_spec_fm',
  'solve_spec_bm',
  '_solve_spec_pt_0',
  '_solve_spec_pt_1',
  'solve_spec_pt',
  'solve_spec_lrp',
  'solve_spec_lrn',
  '_solve_spec_mk_0',
  '_solve_spec_mk_1',
  'solve_spec_mk',
  'solve_spec_dor',
  '_solve_spec_mcc_0',
  '_solve_spec_mcc_1',
  'solve_spec_mcc',
  'solve_spec_ji',
  'solve_spec_ba',
  'solve_npv_ppv',
  'solve_npv_f1_plus',
  'solve_npv_f1_minus',
  '_solve_npv_fm_0',
  '_solve_npv_fm_1',
  'solve_npv_fm',
  'solve_npv_bm',
  '_solve_npv_pt_0',
  '_solve_npv_pt_1',
  'solve_npv_pt',
  'solve_npv_lrp',
  '_solve_npv_mk_0',
  '_solve_npv_mk_1',
  'solve_npv_mk',
  '_solve_npv_dor_0',
  '_solve_npv_dor_1',
  'solve_npv_dor',
  '_solve_npv_mcc_0',
  '_solve_npv_mcc_1',
  'solve_npv_mcc',
  'solve_npv_ji',
  'solve_npv_ba',
  'solve_ppv_f1_plus',
  'solve_ppv_f1_minus',
  '_solve_ppv_fm_0',
  '_solve_ppv_fm_1',
  'solve_ppv_fm',
  'solve_ppv_bm',
  'solve_ppv_lrn',
  '_solve_ppv_mk_0',
  '_solve_ppv_mk_1',
  'solve_ppv_mk',
  '_solve_ppv_dor_0',
  '_solve_ppv_dor_1',
  'solve_ppv_dor',
  '_solve_ppv_mcc_0',
  '_solve_ppv_mcc_1',
  'solve_ppv_mcc',
  'solve_ppv_ji',
  'solve_ppv_ba',
  'solve_f1_plus_f1_minus',
  '_solve_f1_plus_fm_0',
  '_solve_f1_plus_fm_1',
  'solve_f1_plus_fm',
  'solve_f1_plus_bm',
  '_solve_f1_plus_pt_0',
  '_solve_f1_plus_pt_1',
  'solve_f1_plus_pt',
  'solve_f1_plus_lrp',
  'solve_f1_plus_lrn',
  '_solve_f1_plus_mk_0',
  '_solve_f1_plus_mk_1',
  'solve_f1_plus_mk',
  '_solve_f1_plus_dor_0',
  '_solve_f1_plus_dor_1',
  'solve_f1_plus_dor',
  '_solve_f1_plus_mcc_0',
  '_solve_f1_plus_mcc_1',
  'solve_f1_plus_mcc',
  'solve_f1_plus_ba',
  '_solve_f1_minus_fm_0',
  '_solve_f1_minus_fm_1',
  'solve_f1_minus_fm',
  'solve_f1_minus_bm',
  '_solve_f1_minus_pt_0',
  '_solve_f1_minus_pt_1',
  'solve_f1_minus_pt',
  'solve_f1_minus_lrp',
  'solve_f1_minus_lrn',
  '_solve_f1_minus_mk_0',
  '_solve_f1_minus_mk_1',
  'solve_f1_minus_mk',
  '_solve_f1_minus_dor_0',
  '_solve_f1_minus_dor_1',
  'solve_f1_minus_dor',
  '_solve_f1_minus_mcc_0',
  '_solve_f1_minus_mcc_1',
  'solve_f1_minus_mcc',
  'solve_f1_minus_ji',
  'solve_f1_minus_ba',
  '_solve_fm_bm_0',
  '_solve_fm_bm_1',
  'solve_fm_bm',
  '_solve_fm_pt_0',
  '_solve_fm_pt_1',
  '_solve_fm_pt_2',
  'solve_fm_pt',
  '_solve_fm_lrp_0',
  '_solve_fm_lrp_1',
  'solve_fm_lrp',
  '_solve_fm_lrn_0',
  '_solve_fm_lrn_1',
  'solve_fm_lrn',
  '_solve_fm_dor_0',
  '_solve_fm_dor_1',
  '_solve_fm_dor_2',
  'solve_fm_dor',
  '_solve_fm_mcc_0',
  '_solve_fm_mcc_1',
  '_solve_fm_mcc_2',
  'solve_fm_mcc',
  '_solve_fm_ji_0',
  '_solve_fm_ji_1',
  'solve_fm_ji',
  '_solve_fm_ba_0',
  '_solve_fm_ba_1',
  'solve_fm_ba',
  'solve_bm_pt',
  'solve_bm_lrp',
  'solve_bm_lrn',
  '_solve_bm_mk_0',
  '_solve_bm_mk_1',
  'solve_bm_mk',
  '_solve_bm_dor_0',
  '_solve_bm_dor_1',
  'solve_bm_dor',
  '_solve_bm_mcc_0',
  '_solve_bm_mcc_1',
  'solve_bm_mcc',
  'solve_bm_ji',
  '_solve_pt_lrn_0',
  '_solve_pt_lrn_1',
  'solve_pt_lrn',
  '_solve_pt_mk_0',
  '_solve_pt_mk_1',
  '_solve_pt_mk_2',
  '_solve_pt_mk_3',
  '_solve_pt_mk_4',
  '_solve_pt_mk_5',
  'solve_pt_mk',
  '_solve_pt_dor_0',
  '_solve_pt_dor_1',
  '_solve_pt_dor_2',
  'solve_pt_dor',
  '_solve_pt_mcc_0',
  '_solve_pt_mcc_1',
  '_solve_pt_mcc_2',
  '_solve_pt_mcc_3',
  'solve_pt_mcc',
  '_solve_pt_ji_0',
  '_solve_pt_ji_1',
  'solve_pt_ji',
  'solve_pt_ba',
  'solve_lrp_lrn',
  '_solve_lrp_mk_0',
  '_solve_lrp_mk_1',
  'solve_lrp_mk',
  '_solve_lrp_dor_0',
  '_solve_lrp_dor_1',
  'solve_lrp_dor',
  '_solve_lrp_mcc_0',
  '_solve_lrp_mcc_1',
  'solve_lrp_mcc',
  'solve_lrp_ji',
  'solve_lrp_ba',
  '_solve_lrn_mk_0',
  '_solve_lrn_mk_1',
  'solve_lrn_mk',
  '_solve_lrn_dor_0',
  '_solve_lrn_dor_1',
  'solve_lrn_dor',
  '_solve_lrn_mcc_0',
  '_solve_lrn_mcc_1',
  'solve_lrn_mcc',
  'solve_lrn_ji',
  'solve_lrn_ba',
  '_solve_mk_dor_0',
  '_solve_mk_dor_1',
  '_solve_mk_dor_2',
  '_solve_mk_dor_3',
  'solve_mk_dor',
  '_solve_mk_mcc_0',
  '_solve_mk_mcc_1',
  '_solve_mk_mcc_2',
  '_solve_mk_mcc_3',
  '_solve_mk_mcc_4',
  '_solve_mk_mcc_5',
  '_solve_mk_mcc_6',
  '_solve_mk_mcc_7',
  'solve_mk_mcc',
  '_solve_mk_ji_0',
  '_solve_mk_ji_1',
  'solve_mk_ji',
  '_solve_mk_ba_0',
  '_solve_mk_ba_1',
  'solve_mk_ba',
  '_solve_dor_mcc_0',
  '_solve_dor_mcc_1',
  '_solve_dor_mcc_2',
  '_solve_dor_mcc_3',
  'solve_dor_mcc',
  '_solve_dor_ji_0',
  '_solve_dor_ji_1',
  'solve_dor_ji',
  '_solve_dor_ba_0',
  '_solve_dor_ba_1',
  'solve_dor_ba',
  '_solve_mcc_ji_0',
  '_solve_mcc_ji_1',
  'solve_mcc_ji',
  '_solve_mcc_ba_0',
  '_solve_mcc_ba_1',
  'solve_mcc_ba',
  'solve_ji_ba',
]

def solve_acc_sens(*, acc, sens, p, n):
  """
  Solution of for the acc - sens pair

  Args:
    acc (int/float/Interval): the acc score
    sens (int/float/Interval): the sens score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = acc*n + acc*p - p*sens
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_acc_spec(*, acc, spec, p, n):
  """
  Solution of for the acc - spec pair

  Args:
    acc (int/float/Interval): the acc score
    spec (int/float/Interval): the spec score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = acc*n + acc*p - n*spec
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_acc_npv(*, acc, npv, p, n):
  """
  Solution of for the acc - npv pair

  Args:
    acc (int/float/Interval): the acc score
    npv (int/float/Interval): the npv score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*n*npv - acc*n + acc*npv*p - acc*p + npv*p)/(2*npv - 1)
    tn = (acc*n*npv + acc*npv*p - npv*p)/(2*npv - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_acc_ppv(*, acc, ppv, p, n):
  """
  Solution of for the acc - ppv pair

  Args:
    acc (int/float/Interval): the acc score
    ppv (int/float/Interval): the ppv score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*n*ppv + acc*p*ppv - n*ppv)/(2*ppv - 1)
    tn = (acc*n*ppv - acc*n + acc*p*ppv - acc*p + n*ppv)/(2*ppv - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_acc_f1_plus(*, acc, f1_plus, p, n):
  """
  Solution of for the acc - f1_plus pair

  Args:
    acc (int/float/Interval): the acc score
    f1_plus (int/float/Interval): the f1_plus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*f1_plus*n + acc*f1_plus*p - f1_plus*n - f1_plus*p)/(2*f1_plus - 2)
    tn = (acc*f1_plus*n + acc*f1_plus*p - 2*acc*n - 2*acc*p + f1_plus*n + f1_plus*p)/(2*f1_plus - 2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_acc_f1_minus(*, acc, f1_minus, p, n):
  """
  Solution of for the acc - f1_minus pair

  Args:
    acc (int/float/Interval): the acc score
    f1_minus (int/float/Interval): the f1_minus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*f1_minus*n + acc*f1_minus*p - 2*acc*n - 2*acc*p + f1_minus*n + f1_minus*p)/(2*f1_minus - 2)
    tn = (acc*f1_minus*n + acc*f1_minus*p - f1_minus*n - f1_minus*p)/(2*f1_minus - 2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_acc_fm_0(*, acc, fm, p, n):
  """
  Solution of for the acc - fm pair

  Args:
    acc (int/float/Interval): the acc score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(fm*p + sqrt(p*(-acc*n - acc*p + fm**2*p + n)))
    tn = acc*n + acc*p - fm**2*p - fm*sqrt(p*(-acc*n - acc*p + fm**2*p + n))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_acc_fm_1(*, acc, fm, p, n):
  """
  Solution of for the acc - fm pair

  Args:
    acc (int/float/Interval): the acc score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(fm*p - sqrt(p*(-acc*n - acc*p + fm**2*p + n)))
    tn = acc*n + acc*p - fm**2*p + fm*sqrt(p*(-acc*n - acc*p + fm**2*p + n))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_acc_fm(*, acc, fm, p, n):
  """
  Solution of for the acc - fm pair

  Args:
    acc (int/float/Interval): the acc score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_acc_fm_0(acc=acc, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_acc_fm_1(acc=acc, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_acc_bm(*, acc, bm, p, n):
  """
  Solution of for the acc - bm pair

  Args:
    acc (int/float/Interval): the acc score
    bm (int/float/Interval): the bm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*n*p + acc*p**2 - bm*n*p - n*p)/(-n + p)
    tn = (-acc*n**2 - acc*n*p + bm*n*p + n*p)/(-n + p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_acc_pt_0(*, acc, p, n):
  """
  Solution of for the acc - pt pair

  Args:
    acc (int/float/Interval): the acc score
    pt (int/float/Interval): the pt score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(-acc*n - acc*p + n)/(n - p)
    tn = n*(acc*n + acc*p - p)/(n - p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_acc_pt_1(*, acc, pt, p, n):
  """
  Solution of for the acc - pt pair

  Args:
    acc (int/float/Interval): the acc score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(-acc*n*pt**2 + 2*acc*n*pt - acc*n - acc*p*pt**2 + 2*acc*p*pt - acc*p + n*pt**2 - 2*n*pt + n)/(n*pt**2 - p*pt**2 + 2*p*pt - p)
    tn = n*(-acc*n*pt**2 - acc*p*pt**2 + p*pt**2 - 2*p*pt + p)/(-n*pt**2 + p*pt**2 - 2*p*pt + p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_acc_pt(*, acc, pt, p, n):
  """
  Solution of for the acc - pt pair

  Args:
    acc (int/float/Interval): the acc score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_acc_pt_0(acc=acc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_acc_pt_1(acc=acc, pt=pt, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_acc_lrp(*, acc, lrp, p, n):
  """
  Solution of for the acc - lrp pair

  Args:
    acc (int/float/Interval): the acc score
    lrp (int/float/Interval): the lrp score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*lrp*n*p + acc*lrp*p**2 - lrp*n*p)/(lrp*p - n)
    tn = (-acc*n**2 - acc*n*p + lrp*n*p)/(lrp*p - n)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_acc_lrn(*, acc, lrn, p, n):
  """
  Solution of for the acc - lrn pair

  Args:
    acc (int/float/Interval): the acc score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*lrn*n*p + acc*lrn*p**2 - n*p)/(lrn*p - n)
    tn = (-acc*n**2 - acc*n*p + n*p)/(lrn*p - n)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_acc_mk_0(*, acc, mk, p, n):
  """
  Solution of for the acc - mk pair

  Args:
    acc (int/float/Interval): the acc score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (4*acc*mk*n + 4*acc*mk*p - 2*mk*n + 2*mk*p - n + p + sqrt(-8*acc*mk*n**2 - 16*acc*mk*n*p - 8*acc*mk*p**2 + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 4*mk*n**2 + 8*mk*n*p + 4*mk*p**2 + n**2 - 2*n*p + p**2))/(8*mk)
    tn = (4*acc*mk*n + 4*acc*mk*p + 2*mk*n - 2*mk*p + n - p - sqrt(-8*acc*mk*n**2 - 16*acc*mk*n*p - 8*acc*mk*p**2 + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 4*mk*n**2 + 8*mk*n*p + 4*mk*p**2 + n**2 - 2*n*p + p**2))/(8*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_acc_mk_1(*, acc, mk, p, n):
  """
  Solution of for the acc - mk pair

  Args:
    acc (int/float/Interval): the acc score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (4*acc*mk*n + 4*acc*mk*p - 2*mk*n + 2*mk*p - n + p - sqrt(-8*acc*mk*n**2 - 16*acc*mk*n*p - 8*acc*mk*p**2 + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 4*mk*n**2 + 8*mk*n*p + 4*mk*p**2 + n**2 - 2*n*p + p**2))/(8*mk)
    tn = (4*acc*mk*n + 4*acc*mk*p + 2*mk*n - 2*mk*p + n - p + sqrt(-8*acc*mk*n**2 - 16*acc*mk*n*p - 8*acc*mk*p**2 + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 4*mk*n**2 + 8*mk*n*p + 4*mk*p**2 + n**2 - 2*n*p + p**2))/(8*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_acc_mk(*, acc, mk, p, n):
  """
  Solution of for the acc - mk pair

  Args:
    acc (int/float/Interval): the acc score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_acc_mk_0(acc=acc, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_acc_mk_1(acc=acc, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_acc_dor_0(*, acc, dor, p, n):
  """
  Solution of for the acc - dor pair

  Args:
    acc (int/float/Interval): the acc score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*dor*n + acc*dor*p - acc*n - acc*p - dor*n + dor*p + sqrt(acc**2*dor**2*n**2 + 2*acc**2*dor**2*n*p + acc**2*dor**2*p**2 - 2*acc**2*dor*n**2 - 4*acc**2*dor*n*p - 2*acc**2*dor*p**2 + acc**2*n**2 + 2*acc**2*n*p + acc**2*p**2 - 2*acc*dor**2*n**2 - 4*acc*dor**2*n*p - 2*acc*dor**2*p**2 + 2*acc*dor*n**2 + 4*acc*dor*n*p + 2*acc*dor*p**2 + dor**2*n**2 + 2*dor**2*n*p + dor**2*p**2 - 4*dor*n*p))/(2*(dor - 1))
    tn = (acc*dor*n + acc*dor*p - acc*n - acc*p + dor*n - dor*p - sqrt(acc**2*dor**2*n**2 + 2*acc**2*dor**2*n*p + acc**2*dor**2*p**2 - 2*acc**2*dor*n**2 - 4*acc**2*dor*n*p - 2*acc**2*dor*p**2 + acc**2*n**2 + 2*acc**2*n*p + acc**2*p**2 - 2*acc*dor**2*n**2 - 4*acc*dor**2*n*p - 2*acc*dor**2*p**2 + 2*acc*dor*n**2 + 4*acc*dor*n*p + 2*acc*dor*p**2 + dor**2*n**2 + 2*dor**2*n*p + dor**2*p**2 - 4*dor*n*p))/(2*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_acc_dor_1(*, acc, dor, p, n):
  """
  Solution of for the acc - dor pair

  Args:
    acc (int/float/Interval): the acc score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*dor*n + acc*dor*p - acc*n - acc*p - dor*n + dor*p - sqrt(acc**2*dor**2*n**2 + 2*acc**2*dor**2*n*p + acc**2*dor**2*p**2 - 2*acc**2*dor*n**2 - 4*acc**2*dor*n*p - 2*acc**2*dor*p**2 + acc**2*n**2 + 2*acc**2*n*p + acc**2*p**2 - 2*acc*dor**2*n**2 - 4*acc*dor**2*n*p - 2*acc*dor**2*p**2 + 2*acc*dor*n**2 + 4*acc*dor*n*p + 2*acc*dor*p**2 + dor**2*n**2 + 2*dor**2*n*p + dor**2*p**2 - 4*dor*n*p))/(2*(dor - 1))
    tn = (acc*dor*n + acc*dor*p - acc*n - acc*p + dor*n - dor*p + sqrt(acc**2*dor**2*n**2 + 2*acc**2*dor**2*n*p + acc**2*dor**2*p**2 - 2*acc**2*dor*n**2 - 4*acc**2*dor*n*p - 2*acc**2*dor*p**2 + acc**2*n**2 + 2*acc**2*n*p + acc**2*p**2 - 2*acc*dor**2*n**2 - 4*acc*dor**2*n*p - 2*acc*dor**2*p**2 + 2*acc*dor*n**2 + 4*acc*dor*n*p + 2*acc*dor*p**2 + dor**2*n**2 + 2*dor**2*n*p + dor**2*p**2 - 4*dor*n*p))/(2*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_acc_dor(*, acc, dor, p, n):
  """
  Solution of for the acc - dor pair

  Args:
    acc (int/float/Interval): the acc score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_acc_dor_0(acc=acc, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_acc_dor_1(acc=acc, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_acc_mcc_0(*, acc, mcc, p, n):
  """
  Solution of for the acc - mcc pair

  Args:
    acc (int/float/Interval): the acc score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (mcc*sqrt(-n*p*(acc**2*n**2 + 2*acc**2*n*p + acc**2*p**2 - acc*n**2 - 2*acc*n*p - acc*p**2 - mcc**2*n*p + n*p))*(n + p) + p*(4*mcc**2*n*p + n**2 - 2*n*p + p**2) + p*(2*acc*mcc**2*n**2 + 2*acc*mcc**2*n*p - acc*n**2 + acc*p**2 - mcc**2*n**2 - 3*mcc**2*n*p + n*p - p**2))/(4*mcc**2*n*p + n**2 - 2*n*p + p**2)
    tn = (-mcc*sqrt(-n*p*(acc**2*n**2 + 2*acc**2*n*p + acc**2*p**2 - acc*n**2 - 2*acc*n*p - acc*p**2 - mcc**2*n*p + n*p))*(n + p) - p*(2*acc*mcc**2*n**2 + 2*acc*mcc**2*n*p - acc*n**2 + acc*p**2 - mcc**2*n**2 - 3*mcc**2*n*p + n*p - p**2) + (acc*n + acc*p - p)*(4*mcc**2*n*p + n**2 - 2*n*p + p**2))/(4*mcc**2*n*p + n**2 - 2*n*p + p**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_acc_mcc_1(*, acc, mcc, p, n):
  """
  Solution of for the acc - mcc pair

  Args:
    acc (int/float/Interval): the acc score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-mcc*sqrt(-n*p*(acc**2*n**2 + 2*acc**2*n*p + acc**2*p**2 - acc*n**2 - 2*acc*n*p - acc*p**2 - mcc**2*n*p + n*p))*(n + p) + p*(4*mcc**2*n*p + n**2 - 2*n*p + p**2) + p*(2*acc*mcc**2*n**2 + 2*acc*mcc**2*n*p - acc*n**2 + acc*p**2 - mcc**2*n**2 - 3*mcc**2*n*p + n*p - p**2))/(4*mcc**2*n*p + n**2 - 2*n*p + p**2)
    tn = (mcc*sqrt(-n*p*(acc**2*n**2 + 2*acc**2*n*p + acc**2*p**2 - acc*n**2 - 2*acc*n*p - acc*p**2 - mcc**2*n*p + n*p))*(n + p) - p*(2*acc*mcc**2*n**2 + 2*acc*mcc**2*n*p - acc*n**2 + acc*p**2 - mcc**2*n**2 - 3*mcc**2*n*p + n*p - p**2) + (acc*n + acc*p - p)*(4*mcc**2*n*p + n**2 - 2*n*p + p**2))/(4*mcc**2*n*p + n**2 - 2*n*p + p**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_acc_mcc(*, acc, mcc, p, n):
  """
  Solution of for the acc - mcc pair

  Args:
    acc (int/float/Interval): the acc score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_acc_mcc_0(acc=acc, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_acc_mcc_1(acc=acc, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_acc_ji(*, acc, ji, p, n):
  """
  Solution of for the acc - ji pair

  Args:
    acc (int/float/Interval): the acc score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*ji*n + acc*ji*p - ji*n - ji*p)/(ji - 1)
    tn = (-acc*n - acc*p + ji*n + ji*p)/(ji - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_acc_ba(*, acc, ba, p, n):
  """
  Solution of for the acc - ba pair

  Args:
    acc (int/float/Interval): the acc score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (acc*n*p + acc*p**2 - 2.0*ba*n*p)/(-n + p)
    tn = (-acc*n**2 - acc*n*p + 2.0*ba*n*p)/(-n + p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_sens_spec(*, sens, spec, p, n):
  """
  Solution of for the sens - spec pair

  Args:
    sens (int/float/Interval): the sens score
    spec (int/float/Interval): the spec score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_sens_npv(*, sens, npv, p, n):
  """
  Solution of for the sens - npv pair

  Args:
    sens (int/float/Interval): the sens score
    npv (int/float/Interval): the npv score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (npv*p*sens - npv*p)/(npv - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_sens_ppv(*, sens, ppv, p, n):
  """
  Solution of for the sens - ppv pair

  Args:
    sens (int/float/Interval): the sens score
    ppv (int/float/Interval): the ppv score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (n*ppv + p*ppv*sens - p*sens)/ppv
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_sens_f1_plus(*, sens, f1_plus, p, n):
  """
  Solution of for the sens - f1_plus pair

  Args:
    sens (int/float/Interval): the sens score
    f1_plus (int/float/Interval): the f1_plus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (f1_plus*n + f1_plus*p*sens + f1_plus*p - 2*p*sens)/f1_plus
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_sens_f1_minus(*, sens, f1_minus, p, n):
  """
  Solution of for the sens - f1_minus pair

  Args:
    sens (int/float/Interval): the sens score
    f1_minus (int/float/Interval): the f1_minus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (-f1_minus*n + f1_minus*p*sens - f1_minus*p)/(f1_minus - 2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_sens_fm(*, sens, fm, p, n):
  """
  Solution of for the sens - fm pair

  Args:
    sens (int/float/Interval): the sens score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (fm**2*n + fm**2*p*sens - p*sens**2)/fm**2
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_sens_bm(*, sens, bm, p, n):
  """
  Solution of for the sens - bm pair

  Args:
    sens (int/float/Interval): the sens score
    bm (int/float/Interval): the bm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = bm*n - n*sens + n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_sens_pt_0(*, sens, p, n):
  """
  Solution of for the sens - pt pair

  Args:
    sens (int/float/Interval): the sens score
    pt (int/float/Interval): the pt score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = n*(1 - sens)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_sens_pt_1(*, sens, pt, p, n):
  """
  Solution of for the sens - pt pair

  Args:
    sens (int/float/Interval): the sens score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = n*(-pt**2*sens + pt**2 - 2*pt + 1)/(pt**2 - 2*pt + 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_sens_pt(*, sens, pt, p, n):
  """
  Solution of for the sens - pt pair

  Args:
    sens (int/float/Interval): the sens score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_sens_pt_0(sens=sens, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_sens_pt_1(sens=sens, pt=pt, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_sens_lrp(*, sens, lrp, p, n):
  """
  Solution of for the sens - lrp pair

  Args:
    sens (int/float/Interval): the sens score
    lrp (int/float/Interval): the lrp score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (lrp*n - n*sens)/lrp
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_sens_lrn(*, sens, lrn, p, n):
  """
  Solution of for the sens - lrn pair

  Args:
    sens (int/float/Interval): the sens score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (-n*sens + n)/lrn
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_sens_mk_0(*, sens, mk, p, n):
  """
  Solution of for the sens - mk pair

  Args:
    sens (int/float/Interval): the sens score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (mk*n + 2*mk*p*sens - mk*p - p + sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 - 4*mk*n*p*sens + 2*mk*n*p - 4*mk*p**2*sens + 2*mk*p**2 + p**2))/(2*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_sens_mk_1(*, sens, mk, p, n):
  """
  Solution of for the sens - mk pair

  Args:
    sens (int/float/Interval): the sens score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (mk*n + 2*mk*p*sens - mk*p - p - sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 - 4*mk*n*p*sens + 2*mk*n*p - 4*mk*p**2*sens + 2*mk*p**2 + p**2))/(2*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_sens_mk(*, sens, mk, p, n):
  """
  Solution of for the sens - mk pair

  Args:
    sens (int/float/Interval): the sens score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_sens_mk_0(sens=sens, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_sens_mk_1(sens=sens, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_sens_dor(*, sens, dor, p, n):
  """
  Solution of for the sens - dor pair

  Args:
    sens (int/float/Interval): the sens score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = dor*n*(sens - 1)/(dor*sens - dor - sens)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_sens_mcc_0(*, sens, mcc, p, n):
  """
  Solution of for the sens - mcc pair

  Args:
    sens (int/float/Interval): the sens score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (mcc*sqrt(n*(mcc**2*n - 4*p*sens**2 + 4*p*sens))*(n + p)/2 + n*(mcc**2*n + p) - n*(mcc**2*n - 2*mcc**2*p*sens + mcc**2*p + 2*p*sens)/2)/(mcc**2*n + p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_sens_mcc_1(*, sens, mcc, p, n):
  """
  Solution of for the sens - mcc pair

  Args:
    sens (int/float/Interval): the sens score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (-mcc*sqrt(n*(mcc**2*n - 4*p*sens**2 + 4*p*sens))*(n + p)/2 + n*(mcc**2*n + p) - n*(mcc**2*n - 2*mcc**2*p*sens + mcc**2*p + 2*p*sens)/2)/(mcc**2*n + p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_sens_mcc(*, sens, mcc, p, n):
  """
  Solution of for the sens - mcc pair

  Args:
    sens (int/float/Interval): the sens score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_sens_mcc_0(sens=sens, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_sens_mcc_1(sens=sens, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_sens_ji(*, sens, ji, p, n):
  """
  Solution of for the sens - ji pair

  Args:
    sens (int/float/Interval): the sens score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = (ji*n + ji*p - p*sens)/ji
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_sens_ba(*, sens, ba, p, n):
  """
  Solution of for the sens - ba pair

  Args:
    sens (int/float/Interval): the sens score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*sens
    tn = 2.0*ba*n - n*sens
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_spec_npv(*, spec, npv, p, n):
  """
  Solution of for the spec - npv pair

  Args:
    spec (int/float/Interval): the spec score
    npv (int/float/Interval): the npv score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (n*npv*spec - n*spec + npv*p)/npv
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_spec_ppv(*, spec, ppv, p, n):
  """
  Solution of for the spec - ppv pair

  Args:
    spec (int/float/Interval): the spec score
    ppv (int/float/Interval): the ppv score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (n*ppv*spec - n*ppv)/(ppv - 1)
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_spec_f1_plus(*, spec, f1_plus, p, n):
  """
  Solution of for the spec - f1_plus pair

  Args:
    spec (int/float/Interval): the spec score
    f1_plus (int/float/Interval): the f1_plus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (f1_plus*n*spec - f1_plus*n - f1_plus*p)/(f1_plus - 2)
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_spec_f1_minus(*, spec, f1_minus, p, n):
  """
  Solution of for the spec - f1_minus pair

  Args:
    spec (int/float/Interval): the spec score
    f1_minus (int/float/Interval): the f1_minus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (f1_minus*n*spec + f1_minus*n + f1_minus*p - 2*n*spec)/f1_minus
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_spec_fm_0(*, spec, fm, p, n):
  """
  Solution of for the spec - fm pair

  Args:
    spec (int/float/Interval): the spec score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(fm*p + sqrt(p*(fm**2*p - 4*n*spec + 4*n)))/2
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_spec_fm_1(*, spec, fm, p, n):
  """
  Solution of for the spec - fm pair

  Args:
    spec (int/float/Interval): the spec score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(fm*p - sqrt(p*(fm**2*p - 4*n*spec + 4*n)))/2
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_spec_fm(*, spec, fm, p, n):
  """
  Solution of for the spec - fm pair

  Args:
    spec (int/float/Interval): the spec score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_spec_fm_0(spec=spec, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_spec_fm_1(spec=spec, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_spec_bm(*, spec, bm, p, n):
  """
  Solution of for the spec - bm pair

  Args:
    spec (int/float/Interval): the spec score
    bm (int/float/Interval): the bm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = bm*p - p*spec + p
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_spec_pt_0(*, spec, p, n):
  """
  Solution of for the spec - pt pair

  Args:
    spec (int/float/Interval): the spec score
    pt (int/float/Interval): the pt score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(1 - spec)
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_spec_pt_1(*, spec, pt, p, n):
  """
  Solution of for the spec - pt pair

  Args:
    spec (int/float/Interval): the spec score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(-pt**2*spec + pt**2 + 2*pt*spec - 2*pt - spec + 1)/pt**2
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_spec_pt(*, spec, pt, p, n):
  """
  Solution of for the spec - pt pair

  Args:
    spec (int/float/Interval): the spec score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_spec_pt_0(spec=spec, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_spec_pt_1(spec=spec, pt=pt, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_spec_lrp(*, spec, lrp, p, n):
  """
  Solution of for the spec - lrp pair

  Args:
    spec (int/float/Interval): the spec score
    lrp (int/float/Interval): the lrp score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = -lrp*p*spec + lrp*p
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_spec_lrn(*, spec, lrn, p, n):
  """
  Solution of for the spec - lrn pair

  Args:
    spec (int/float/Interval): the spec score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = -lrn*p*spec + p
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_spec_mk_0(*, spec, mk, p, n):
  """
  Solution of for the spec - mk pair

  Args:
    spec (int/float/Interval): the spec score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2*mk*n*spec - mk*n + mk*p - n + sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 - 4*mk*n**2*spec + 2*mk*n**2 - 4*mk*n*p*spec + 2*mk*n*p + n**2))/(2*mk)
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_spec_mk_1(*, spec, mk, p, n):
  """
  Solution of for the spec - mk pair

  Args:
    spec (int/float/Interval): the spec score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2*mk*n*spec - mk*n + mk*p - n - sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 - 4*mk*n**2*spec + 2*mk*n**2 - 4*mk*n*p*spec + 2*mk*n*p + n**2))/(2*mk)
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_spec_mk(*, spec, mk, p, n):
  """
  Solution of for the spec - mk pair

  Args:
    spec (int/float/Interval): the spec score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_spec_mk_0(spec=spec, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_spec_mk_1(spec=spec, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_spec_dor(*, spec, dor, p, n):
  """
  Solution of for the spec - dor pair

  Args:
    spec (int/float/Interval): the spec score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = dor*p*(spec - 1)/(dor*spec - dor - spec)
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_spec_mcc_0(*, spec, mcc, p, n):
  """
  Solution of for the spec - mcc pair

  Args:
    spec (int/float/Interval): the spec score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (mcc*sqrt(p*(mcc**2*p - 4*n*spec**2 + 4*n*spec))*(n + p)/2 + p*(mcc**2*p + n) - p*(-2*mcc**2*n*spec + mcc**2*n + mcc**2*p + 2*n*spec)/2)/(mcc**2*p + n)
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_spec_mcc_1(*, spec, mcc, p, n):
  """
  Solution of for the spec - mcc pair

  Args:
    spec (int/float/Interval): the spec score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-mcc*sqrt(p*(mcc**2*p - 4*n*spec**2 + 4*n*spec))*(n + p)/2 + p*(mcc**2*p + n) - p*(-2*mcc**2*n*spec + mcc**2*n + mcc**2*p + 2*n*spec)/2)/(mcc**2*p + n)
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_spec_mcc(*, spec, mcc, p, n):
  """
  Solution of for the spec - mcc pair

  Args:
    spec (int/float/Interval): the spec score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_spec_mcc_0(spec=spec, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_spec_mcc_1(spec=spec, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_spec_ji(*, spec, ji, p, n):
  """
  Solution of for the spec - ji pair

  Args:
    spec (int/float/Interval): the spec score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = -ji*n*spec + ji*n + ji*p
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_spec_ba(*, spec, ba, p, n):
  """
  Solution of for the spec - ba pair

  Args:
    spec (int/float/Interval): the spec score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 2.0*ba*p - p*spec
    tn = n*spec
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_npv_ppv(*, npv, ppv, p, n):
  """
  Solution of for the npv - ppv pair

  Args:
    npv (int/float/Interval): the npv score
    ppv (int/float/Interval): the ppv score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (n*npv*ppv - n*ppv + npv*p*ppv)/(npv + ppv - 1)
    tn = (n*npv*ppv + npv*p*ppv - npv*p)/(npv + ppv - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_npv_f1_plus(*, npv, f1_plus, p, n):
  """
  Solution of for the npv - f1_plus pair

  Args:
    npv (int/float/Interval): the npv score
    f1_plus (int/float/Interval): the f1_plus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (f1_plus*n*npv - f1_plus*n + 2*f1_plus*npv*p - f1_plus*p)/(f1_plus + 2*npv - 2)
    tn = (f1_plus*n*npv + 2*f1_plus*npv*p - 2*npv*p)/(f1_plus + 2*npv - 2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_npv_f1_minus(*, npv, f1_minus, p, n):
  """
  Solution of for the npv - f1_minus pair

  Args:
    npv (int/float/Interval): the npv score
    f1_minus (int/float/Interval): the f1_minus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-f1_minus*n*npv + f1_minus*n + f1_minus*p - 2*npv*p)/(f1_minus - 2*npv)
    tn = -f1_minus*n*npv/(f1_minus - 2*npv)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_npv_fm_0(*, npv, fm, p, n):
  """
  Solution of for the npv - fm pair

  Args:
    npv (int/float/Interval): the npv score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(-fm*p + sqrt(p*(fm**2*p + 4*n*npv**2 - 8*n*npv + 4*n + 4*npv**2*p - 4*npv*p)))/(2*(npv - 1))
    tn = npv*(-fm**2*p + fm*sqrt(p*(fm**2*p + 4*n*npv**2 - 8*n*npv + 4*n + 4*npv**2*p - 4*npv*p)) - 2*npv*p + 2*p)/(2*(npv**2 - 2*npv + 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_npv_fm_1(*, npv, fm, p, n):
  """
  Solution of for the npv - fm pair

  Args:
    npv (int/float/Interval): the npv score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(-fm*p - sqrt(p*(fm**2*p + 4*n*npv**2 - 8*n*npv + 4*n + 4*npv**2*p - 4*npv*p)))/(2*(npv - 1))
    tn = npv*(-fm**2*p - fm*sqrt(p*(fm**2*p + 4*n*npv**2 - 8*n*npv + 4*n + 4*npv**2*p - 4*npv*p)) - 2*npv*p + 2*p)/(2*(npv**2 - 2*npv + 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_npv_fm(*, npv, fm, p, n):
  """
  Solution of for the npv - fm pair

  Args:
    npv (int/float/Interval): the npv score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_npv_fm_0(npv=npv, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_npv_fm_1(npv=npv, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_npv_bm(*, npv, bm, p, n):
  """
  Solution of for the npv - bm pair

  Args:
    npv (int/float/Interval): the npv score
    bm (int/float/Interval): the bm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (bm*n*npv*p - bm*n*p + n*npv*p - n*p + npv*p**2)/(n*npv - n + npv*p)
    tn = bm*n*npv*p/(n*npv - n + npv*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_npv_pt_0(*, p):
  """
  Solution of for the npv - pt pair

  Args:
    npv (int/float/Interval): the npv score
    pt (int/float/Interval): the pt score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_npv_pt_1(*, npv, pt, p, n):
  """
  Solution of for the npv - pt pair

  Args:
    npv (int/float/Interval): the npv score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(n*npv*pt**2 - n*pt**2 - n*(2*npv*pt - npv - 2*pt + 1) + npv*p*pt**2 - 2*npv*p*pt + npv*p)/(n*npv*pt**2 - n*pt**2 + npv*p*pt**2 - 2*npv*p*pt + npv*p)
    tn = n*npv*p*(1 - 2*pt)/(n*npv*pt**2 - n*pt**2 + npv*p*pt**2 - 2*npv*p*pt + npv*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_npv_pt(*, npv, pt, p, n):
  """
  Solution of for the npv - pt pair

  Args:
    npv (int/float/Interval): the npv score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_npv_pt_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_npv_pt_1(npv=npv, pt=pt, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_npv_lrp(*, npv, lrp, p, n):
  """
  Solution of for the npv - lrp pair

  Args:
    npv (int/float/Interval): the npv score
    lrp (int/float/Interval): the lrp score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (lrp*n*npv*p - lrp*n*p + lrp*npv*p**2)/(lrp*npv*p + n*npv - n)
    tn = (lrp*n*npv*p - n*npv*p)/(lrp*npv*p + n*npv - n)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_npv_mk_0(*, p):
  """
  Solution of for the npv - mk pair

  Args:
    npv (int/float/Interval): the npv score
    mk (int/float/Interval): the mk score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_npv_mk_1(*, npv, mk, p, n):
  """
  Solution of for the npv - mk pair

  Args:
    npv (int/float/Interval): the npv score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (mk - npv + 1)*(n*npv - n + npv*p)/mk
    tn = npv*(mk*n + mk*p - n*npv + n - npv*p)/mk
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_npv_mk(*, npv, mk, p, n):
  """
  Solution of for the npv - mk pair

  Args:
    npv (int/float/Interval): the npv score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_npv_mk_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_npv_mk_1(npv=npv, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_npv_dor_0(*, p):
  """
  Solution of for the npv - dor pair

  Args:
    npv (int/float/Interval): the npv score
    dor (int/float/Interval): the dor score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_npv_dor_1(*, npv, dor, p, n):
  """
  Solution of for the npv - dor pair

  Args:
    npv (int/float/Interval): the npv score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = dor*(n*npv - n + npv*p)/(npv*(dor - 1))
    tn = (dor*n*npv - dor*n + npv*p)/((dor - 1)*(npv - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_npv_dor(*, npv, dor, p, n):
  """
  Solution of for the npv - dor pair

  Args:
    npv (int/float/Interval): the npv score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_npv_dor_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_npv_dor_1(npv=npv, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_npv_mcc_0(*, p):
  """
  Solution of for the npv - mcc pair

  Args:
    npv (int/float/Interval): the npv score
    mcc (int/float/Interval): the mcc score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_npv_mcc_1(*, npv, mcc, p, n):
  """
  Solution of for the npv - mcc pair

  Args:
    npv (int/float/Interval): the npv score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = mcc**2*n*p*(n*npv - n + npv*p - p)/(mcc**2*n*p + n**2*npv**2 - 2*n**2*npv + n**2 + 2*n*npv**2*p - 2*n*npv*p + npv**2*p**2) + p
    tn = mcc**2*n*npv*p*(n + p)/(mcc**2*n*p + n**2*npv**2 - 2*n**2*npv + n**2 + 2*n*npv**2*p - 2*n*npv*p + npv**2*p**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_npv_mcc(*, npv, mcc, p, n):
  """
  Solution of for the npv - mcc pair

  Args:
    npv (int/float/Interval): the npv score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_npv_mcc_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_npv_mcc_1(npv=npv, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_npv_ji(*, npv, ji, p, n):
  """
  Solution of for the npv - ji pair

  Args:
    npv (int/float/Interval): the npv score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (ji*n*npv - ji*n + 2*ji*npv*p - ji*p)/(ji*npv + npv - 1)
    tn = (ji*n*npv + ji*npv*p - npv*p)/(ji*npv + npv - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_npv_ba(*, npv, ba, p, n):
  """
  Solution of for the npv - ba pair

  Args:
    npv (int/float/Interval): the npv score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2.0*ba*n*npv*p - 2.0*ba*n*p + npv*p**2)/(n*npv - n + npv*p)
    tn = (2.0*ba*n*npv*p - n*npv*p)/(n*npv - n + npv*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_ppv_f1_plus(*, ppv, f1_plus, p, n):
  """
  Solution of for the ppv - f1_plus pair

  Args:
    ppv (int/float/Interval): the ppv score
    f1_plus (int/float/Interval): the f1_plus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = -f1_plus*p*ppv/(f1_plus - 2*ppv)
    tn = (f1_plus*n - f1_plus*p*ppv + f1_plus*p - 2*n*ppv)/(f1_plus - 2*ppv)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_ppv_f1_minus(*, ppv, f1_minus, p, n):
  """
  Solution of for the ppv - f1_minus pair

  Args:
    ppv (int/float/Interval): the ppv score
    f1_minus (int/float/Interval): the f1_minus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2*f1_minus*n*ppv + f1_minus*p*ppv - 2*n*ppv)/(f1_minus + 2*ppv - 2)
    tn = (2*f1_minus*n*ppv - f1_minus*n + f1_minus*p*ppv - f1_minus*p)/(f1_minus + 2*ppv - 2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_ppv_fm_0(*, n):
  """
  Solution of for the ppv - fm pair

  Args:
    ppv (int/float/Interval): the ppv score
    fm (int/float/Interval): the fm score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_ppv_fm_1(*, ppv, fm, p, n):
  """
  Solution of for the ppv - fm pair

  Args:
    ppv (int/float/Interval): the ppv score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm**2*p/ppv
    tn = (fm**2*p*ppv - fm**2*p + n*ppv**2)/ppv**2
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_ppv_fm(*, ppv, fm, p, n):
  """
  Solution of for the ppv - fm pair

  Args:
    ppv (int/float/Interval): the ppv score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_ppv_fm_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_ppv_fm_1(ppv=ppv, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_ppv_bm(*, ppv, bm, p, n):
  """
  Solution of for the ppv - bm pair

  Args:
    ppv (int/float/Interval): the ppv score
    bm (int/float/Interval): the bm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = bm*n*p*ppv/(n*ppv + p*ppv - p)
    tn = (bm*n*p*ppv - bm*n*p + n**2*ppv + n*p*ppv - n*p)/(n*ppv + p*ppv - p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_ppv_lrn(*, ppv, lrn, p, n):
  """
  Solution of for the ppv - lrn pair

  Args:
    ppv (int/float/Interval): the ppv score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-lrn*n*p*ppv + n*p*ppv)/(lrn*p*ppv - lrn*p + n*ppv)
    tn = (n**2*ppv + n*p*ppv - n*p)/(lrn*p*ppv - lrn*p + n*ppv)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_ppv_mk_0(*, n):
  """
  Solution of for the ppv - mk pair

  Args:
    ppv (int/float/Interval): the ppv score
    mk (int/float/Interval): the mk score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_ppv_mk_1(*, ppv, mk, p, n):
  """
  Solution of for the ppv - mk pair

  Args:
    ppv (int/float/Interval): the ppv score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = ppv*(mk*n + mk*p - n*ppv - p*ppv + p)/mk
    tn = (mk - ppv + 1)*(n*ppv + p*ppv - p)/mk
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_ppv_mk(*, ppv, mk, p, n):
  """
  Solution of for the ppv - mk pair

  Args:
    ppv (int/float/Interval): the ppv score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_ppv_mk_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_ppv_mk_1(ppv=ppv, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_ppv_dor_0(*, n):
  """
  Solution of for the ppv - dor pair

  Args:
    ppv (int/float/Interval): the ppv score
    dor (int/float/Interval): the dor score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_ppv_dor_1(*, ppv, dor, p, n):
  """
  Solution of for the ppv - dor pair

  Args:
    ppv (int/float/Interval): the ppv score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor*p*ppv - dor*p + n*ppv)/((dor - 1)*(ppv - 1))
    tn = dor*(n*ppv + p*ppv - p)/(ppv*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_ppv_dor(*, ppv, dor, p, n):
  """
  Solution of for the ppv - dor pair

  Args:
    ppv (int/float/Interval): the ppv score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_ppv_dor_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_ppv_dor_1(ppv=ppv, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_ppv_mcc_0(*, n):
  """
  Solution of for the ppv - mcc pair

  Args:
    ppv (int/float/Interval): the ppv score
    mcc (int/float/Interval): the mcc score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_ppv_mcc_1(*, ppv, mcc, p, n):
  """
  Solution of for the ppv - mcc pair

  Args:
    ppv (int/float/Interval): the ppv score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = mcc**2*n*p*ppv*(n + p)/(mcc**2*n*p + n**2*ppv**2 + 2*n*p*ppv**2 - 2*n*p*ppv + p**2*ppv**2 - 2*p**2*ppv + p**2)
    tn = n*(mcc**2*n*p*ppv + mcc**2*p**2*ppv - mcc**2*p**2 + n**2*ppv**2 + 2*n*p*ppv**2 - 2*n*p*ppv + p**2*ppv**2 - 2*p**2*ppv + p**2)/(mcc**2*n*p + n**2*ppv**2 + 2*n*p*ppv**2 - 2*n*p*ppv + p**2*ppv**2 - 2*p**2*ppv + p**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_ppv_mcc(*, ppv, mcc, p, n):
  """
  Solution of for the ppv - mcc pair

  Args:
    ppv (int/float/Interval): the ppv score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_ppv_mcc_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_ppv_mcc_1(ppv=ppv, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_ppv_ji(*, ppv, ji, p, n):
  """
  Solution of for the ppv - ji pair

  Args:
    ppv (int/float/Interval): the ppv score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = ji*p*ppv/(ji*ppv - ji + ppv)
    tn = (ji*n*ppv - ji*n + ji*p*ppv - ji*p + n*ppv)/(ji*ppv - ji + ppv)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_ppv_ba(*, ppv, ba, p, n):
  """
  Solution of for the ppv - ba pair

  Args:
    ppv (int/float/Interval): the ppv score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2.0*ba*n*p*ppv - n*p*ppv)/(n*ppv + p*ppv - p)
    tn = (2.0*ba*n*p*ppv - 2.0*ba*n*p + n**2*ppv)/(n*ppv + p*ppv - p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_f1_plus_f1_minus(*, f1_plus, f1_minus, p, n):
  """
  Solution of for the f1_plus - f1_minus pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    f1_minus (int/float/Interval): the f1_minus score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (f1_minus*f1_plus*n + f1_minus*f1_plus*p - f1_plus*n - f1_plus*p)/(f1_minus + f1_plus - 2)
    tn = (f1_minus*f1_plus*n + f1_minus*f1_plus*p - f1_minus*n - f1_minus*p)/(f1_minus + f1_plus - 2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_f1_plus_fm_0(*, f1_plus, fm, p, n):
  """
  Solution of for the f1_plus - fm pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*p*(fm + sqrt(-f1_plus**2 + fm**2))/f1_plus
    tn = n + p + fm**2*p/f1_plus + fm*p*sqrt(-f1_plus**2 + fm**2)/f1_plus - 2*fm**2*p/f1_plus**2 - 2*fm*p*sqrt(-f1_plus**2 + fm**2)/f1_plus**2
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_f1_plus_fm_1(*, f1_plus, fm, p, n):
  """
  Solution of for the f1_plus - fm pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*p*(fm - sqrt(-f1_plus**2 + fm**2))/f1_plus
    tn = n + p + fm**2*p/f1_plus - fm*p*sqrt(-f1_plus**2 + fm**2)/f1_plus - 2*fm**2*p/f1_plus**2 + 2*fm*p*sqrt(-f1_plus**2 + fm**2)/f1_plus**2
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_f1_plus_fm(*, f1_plus, fm, p, n):
  """
  Solution of for the f1_plus - fm pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_f1_plus_fm_0(f1_plus=f1_plus, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_f1_plus_fm_1(f1_plus=f1_plus, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_f1_plus_bm(*, f1_plus, bm, p, n):
  """
  Solution of for the f1_plus - bm pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    bm (int/float/Interval): the bm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (bm*f1_plus*n*p - f1_plus*p**2)/(f1_plus*n + f1_plus*p - 2*p)
    tn = (bm*f1_plus*n*p - 2*bm*n*p + f1_plus*n**2 + 2*f1_plus*n*p - 2*n*p)/(f1_plus*n + f1_plus*p - 2*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_f1_plus_pt_0(*, f1_plus, p, n):
  """
  Solution of for the f1_plus - pt pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    pt (int/float/Interval): the pt score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = -f1_plus*p**2/(f1_plus*n + f1_plus*p - 2*p)
    tn = n*(f1_plus*n + 2*f1_plus*p - 2*p)/(f1_plus*n + f1_plus*p - 2*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_f1_plus_pt_1(*, f1_plus, pt, p, n):
  """
  Solution of for the f1_plus - pt pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = f1_plus*p**2*(-pt**2 + 2*pt - 1)/(f1_plus*n*pt**2 + f1_plus*p*pt**2 - 2*f1_plus*p*pt + f1_plus*p - 2*p*pt**2 + 4*p*pt - 2*p)
    tn = n*(f1_plus*n*pt**2 + 2*f1_plus*p*pt**2 - 2*f1_plus*p*pt + f1_plus*p - 2*p*pt**2 + 4*p*pt - 2*p)/(f1_plus*n*pt**2 + f1_plus*p*pt**2 - 2*f1_plus*p*pt + f1_plus*p - 2*p*pt**2 + 4*p*pt - 2*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_f1_plus_pt(*, f1_plus, pt, p, n):
  """
  Solution of for the f1_plus - pt pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_f1_plus_pt_0(f1_plus=f1_plus, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_f1_plus_pt_1(f1_plus=f1_plus, pt=pt, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_f1_plus_lrp(*, f1_plus, lrp, p, n):
  """
  Solution of for the f1_plus - lrp pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    lrp (int/float/Interval): the lrp score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = -f1_plus*lrp*p**2/(f1_plus*lrp*p + f1_plus*n - 2*lrp*p)
    tn = (f1_plus*lrp*n*p + f1_plus*n**2 + f1_plus*n*p - 2*lrp*n*p)/(f1_plus*lrp*p + f1_plus*n - 2*lrp*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_f1_plus_lrn(*, f1_plus, lrn, p, n):
  """
  Solution of for the f1_plus - lrn pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-f1_plus*lrn*n*p - f1_plus*lrn*p**2 + f1_plus*n*p)/(f1_plus*lrn*p + f1_plus*n - 2*lrn*p)
    tn = (f1_plus*n**2 + 2*f1_plus*n*p - 2*n*p)/(f1_plus*lrn*p + f1_plus*n - 2*lrn*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_f1_plus_mk_0(*, f1_plus, mk, p, n):
  """
  Solution of for the f1_plus - mk pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = f1_plus*(-f1_plus*n - f1_plus*p + 2*mk*n + 6*mk*p + 2*p + sqrt(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*mk*n**2 - 16*f1_plus*mk*n*p - 12*f1_plus*mk*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n*p + 8*mk*p**2 + 4*p**2))/(8*mk)
    tn = (-f1_plus**2*n - f1_plus**2*p + 2*f1_plus*mk*n + 6*f1_plus*mk*p + 2*f1_plus*n + 4*f1_plus*p + f1_plus*sqrt(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*mk*n**2 - 16*f1_plus*mk*n*p - 12*f1_plus*mk*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n*p + 8*mk*p**2 + 4*p**2) + 4*mk*n - 4*mk*p - 4*p - 2*sqrt(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*mk*n**2 - 16*f1_plus*mk*n*p - 12*f1_plus*mk*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n*p + 8*mk*p**2 + 4*p**2))/(8*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_f1_plus_mk_1(*, f1_plus, mk, p, n):
  """
  Solution of for the f1_plus - mk pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = f1_plus*(-f1_plus*n - f1_plus*p + 2*mk*n + 6*mk*p + 2*p - sqrt(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*mk*n**2 - 16*f1_plus*mk*n*p - 12*f1_plus*mk*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n*p + 8*mk*p**2 + 4*p**2))/(8*mk)
    tn = (-f1_plus**2*n - f1_plus**2*p + 2*f1_plus*mk*n + 6*f1_plus*mk*p + 2*f1_plus*n + 4*f1_plus*p - f1_plus*sqrt(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*mk*n**2 - 16*f1_plus*mk*n*p - 12*f1_plus*mk*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n*p + 8*mk*p**2 + 4*p**2) + 4*mk*n - 4*mk*p - 4*p + 2*sqrt(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*mk*n**2 - 16*f1_plus*mk*n*p - 12*f1_plus*mk*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n*p + 8*mk*p**2 + 4*p**2))/(8*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_f1_plus_mk(*, f1_plus, mk, p, n):
  """
  Solution of for the f1_plus - mk pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_f1_plus_mk_0(f1_plus=f1_plus, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_f1_plus_mk_1(f1_plus=f1_plus, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_f1_plus_dor_0(*, f1_plus, dor, p, n):
  """
  Solution of for the f1_plus - dor pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-2*dor*p + f1_plus*n + f1_plus*p + sqrt(4*dor**2*f1_plus**2*p**2 - 8*dor**2*f1_plus*p**2 + 4*dor**2*p**2 - 4*dor*f1_plus**2*p**2 - 4*dor*f1_plus*n*p + 4*dor*f1_plus*p**2 + f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2))/(2*(dor*f1_plus - 2*dor - f1_plus + 2))
    tn = (dor*f1_plus*n + dor*f1_plus*p - dor*p - f1_plus*n/2 - f1_plus*p/2 + sqrt(4*dor**2*f1_plus**2*p**2 - 8*dor**2*f1_plus*p**2 + 4*dor**2*p**2 - 4*dor*f1_plus**2*p**2 - 4*dor*f1_plus*n*p + 4*dor*f1_plus*p**2 + f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2)/2)/(f1_plus*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_f1_plus_dor_1(*, f1_plus, dor, p, n):
  """
  Solution of for the f1_plus - dor pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-2*dor*p + f1_plus*n + f1_plus*p - sqrt(4*dor**2*f1_plus**2*p**2 - 8*dor**2*f1_plus*p**2 + 4*dor**2*p**2 - 4*dor*f1_plus**2*p**2 - 4*dor*f1_plus*n*p + 4*dor*f1_plus*p**2 + f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2))/(2*(dor*f1_plus - 2*dor - f1_plus + 2))
    tn = (dor*f1_plus*n + dor*f1_plus*p - dor*p - f1_plus*n/2 - f1_plus*p/2 - sqrt(4*dor**2*f1_plus**2*p**2 - 8*dor**2*f1_plus*p**2 + 4*dor**2*p**2 - 4*dor*f1_plus**2*p**2 - 4*dor*f1_plus*n*p + 4*dor*f1_plus*p**2 + f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2)/2)/(f1_plus*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_f1_plus_dor(*, f1_plus, dor, p, n):
  """
  Solution of for the f1_plus - dor pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_f1_plus_dor_0(f1_plus=f1_plus, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_f1_plus_dor_1(f1_plus=f1_plus, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_f1_plus_mcc_0(*, f1_plus, mcc, p, n):
  """
  Solution of for the f1_plus - mcc pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = f1_plus*p*(-f1_plus*n*p - f1_plus*p**2 + mcc**2*n**2 + 3*mcc**2*n*p + mcc*sqrt(-n*(f1_plus**2*n + 2*f1_plus**2*p - 2*f1_plus*p - mcc**2*n))*(n + p) + 2*p**2)/(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mcc**2*n*p + 4*p**2)
    tn = (-p*(f1_plus - 2)*(f1_plus**2*n**2 + 3*f1_plus**2*n*p + 2*f1_plus**2*p**2 - f1_plus*mcc**2*n**2 - 3*f1_plus*mcc**2*n*p - f1_plus*mcc*sqrt(-n*(f1_plus**2*n + 2*f1_plus**2*p - 2*f1_plus*p - mcc**2*n))*(n + p) - 4*f1_plus*n*p - 6*f1_plus*p**2 + 4*mcc**2*n*p + 4*p**2) + (f1_plus*n + 2*f1_plus*p - 2*p)*(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mcc**2*n*p + 4*p**2))/(f1_plus*(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mcc**2*n*p + 4*p**2))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_f1_plus_mcc_1(*, f1_plus, mcc, p, n):
  """
  Solution of for the f1_plus - mcc pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = f1_plus*p*(-f1_plus*n*p - f1_plus*p**2 + mcc**2*n**2 + 3*mcc**2*n*p - mcc*sqrt(-n*(f1_plus**2*n + 2*f1_plus**2*p - 2*f1_plus*p - mcc**2*n))*(n + p) + 2*p**2)/(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mcc**2*n*p + 4*p**2)
    tn = (-p*(f1_plus - 2)*(f1_plus**2*n**2 + 3*f1_plus**2*n*p + 2*f1_plus**2*p**2 - f1_plus*mcc**2*n**2 - 3*f1_plus*mcc**2*n*p + f1_plus*mcc*sqrt(-n*(f1_plus**2*n + 2*f1_plus**2*p - 2*f1_plus*p - mcc**2*n))*(n + p) - 4*f1_plus*n*p - 6*f1_plus*p**2 + 4*mcc**2*n*p + 4*p**2) + (f1_plus*n + 2*f1_plus*p - 2*p)*(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mcc**2*n*p + 4*p**2))/(f1_plus*(f1_plus**2*n**2 + 2*f1_plus**2*n*p + f1_plus**2*p**2 - 4*f1_plus*n*p - 4*f1_plus*p**2 + 4*mcc**2*n*p + 4*p**2))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_f1_plus_mcc(*, f1_plus, mcc, p, n):
  """
  Solution of for the f1_plus - mcc pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_f1_plus_mcc_0(f1_plus=f1_plus, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_f1_plus_mcc_1(f1_plus=f1_plus, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_f1_plus_ba(*, f1_plus, ba, p, n):
  """
  Solution of for the f1_plus - ba pair

  Args:
    f1_plus (int/float/Interval): the f1_plus score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2.0*ba*f1_plus*n*p - f1_plus*n*p - f1_plus*p**2)/(f1_plus*n + f1_plus*p - 2.0*p)
    tn = (2.0*ba*f1_plus*n*p - 4.0*ba*n*p + f1_plus*n**2 + f1_plus*n*p)/(f1_plus*n + f1_plus*p - 2.0*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_f1_minus_fm_0(*, f1_minus, fm, p, n):
  """
  Solution of for the f1_minus - fm pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(-fm*p + sqrt(p*(2*f1_minus**2*n + f1_minus**2*p - 6*f1_minus*n - 2*f1_minus*p + fm**2*p + 4*n)))/(f1_minus - 2)
    tn = f1_minus*(-f1_minus*n - f1_minus*p - fm**2*p + fm*sqrt(p*(2*f1_minus**2*n + f1_minus**2*p - 6*f1_minus*n - 2*f1_minus*p + fm**2*p + 4*n)) + 2*n + 2*p)/(f1_minus**2 - 4*f1_minus + 4)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_f1_minus_fm_1(*, f1_minus, fm, p, n):
  """
  Solution of for the f1_minus - fm pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(-fm*p - sqrt(p*(2*f1_minus**2*n + f1_minus**2*p - 6*f1_minus*n - 2*f1_minus*p + fm**2*p + 4*n)))/(f1_minus - 2)
    tn = f1_minus*(-f1_minus*n - f1_minus*p - fm**2*p - fm*sqrt(p*(2*f1_minus**2*n + f1_minus**2*p - 6*f1_minus*n - 2*f1_minus*p + fm**2*p + 4*n)) + 2*n + 2*p)/(f1_minus**2 - 4*f1_minus + 4)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_f1_minus_fm(*, f1_minus, fm, p, n):
  """
  Solution of for the f1_minus - fm pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    fm (int/float/Interval): the fm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_f1_minus_fm_0(f1_minus=f1_minus, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_f1_minus_fm_1(f1_minus=f1_minus, fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_f1_minus_bm(*, f1_minus, bm, p, n):
  """
  Solution of for the f1_minus - bm pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    bm (int/float/Interval): the bm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (bm*f1_minus*n*p - 2*bm*n*p + 2*f1_minus*n*p + f1_minus*p**2 - 2*n*p)/(f1_minus*n + f1_minus*p - 2*n)
    tn = (bm*f1_minus*n*p - f1_minus*n**2)/(f1_minus*n + f1_minus*p - 2*n)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_f1_minus_pt_0(*, f1_minus, p, n):
  """
  Solution of for the f1_minus - pt pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    pt (int/float/Interval): the pt score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(2*f1_minus*n + f1_minus*p - 2*n)/(f1_minus*n + f1_minus*p - 2*n)
    tn = -f1_minus*n**2/(f1_minus*n + f1_minus*p - 2*n)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_f1_minus_pt_1(*, f1_minus, pt, p, n):
  """
  Solution of for the f1_minus - pt pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(f1_minus*n*pt**2 + f1_minus*p*pt**2 - 2*f1_minus*p*pt + f1_minus*p - 2*n*pt**2 + n*(f1_minus*pt**2 - 4*f1_minus*pt + 2*f1_minus + 4*pt - 2))/(f1_minus*n*pt**2 + f1_minus*p*pt**2 - 2*f1_minus*p*pt + f1_minus*p - 2*n*pt**2)
    tn = f1_minus*n*(-n*pt**2 - 2*p*pt + p)/(f1_minus*n*pt**2 + f1_minus*p*pt**2 - 2*f1_minus*p*pt + f1_minus*p - 2*n*pt**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_f1_minus_pt(*, f1_minus, pt, p, n):
  """
  Solution of for the f1_minus - pt pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_f1_minus_pt_0(f1_minus=f1_minus, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_f1_minus_pt_1(f1_minus=f1_minus, pt=pt, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_f1_minus_lrp(*, f1_minus, lrp, p, n):
  """
  Solution of for the f1_minus - lrp pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    lrp (int/float/Interval): the lrp score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2*f1_minus*lrp*n*p + f1_minus*lrp*p**2 - 2*lrp*n*p)/(f1_minus*lrp*p + f1_minus*n - 2*n)
    tn = (f1_minus*lrp*n*p - f1_minus*n**2 - f1_minus*n*p)/(f1_minus*lrp*p + f1_minus*n - 2*n)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_f1_minus_lrn(*, f1_minus, lrn, p, n):
  """
  Solution of for the f1_minus - lrn pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (f1_minus*lrn*n*p + f1_minus*lrn*p**2 + f1_minus*n*p - 2*n*p)/(f1_minus*lrn*p + f1_minus*n - 2*n)
    tn = -f1_minus*n**2/(f1_minus*lrn*p + f1_minus*n - 2*n)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_f1_minus_mk_0(*, f1_minus, mk, p, n):
  """
  Solution of for the f1_minus - mk pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-f1_minus**2*n - f1_minus**2*p + 6*f1_minus*mk*n + 2*f1_minus*mk*p + 4*f1_minus*n + 2*f1_minus*p + f1_minus*sqrt(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 12*f1_minus*mk*n**2 - 16*f1_minus*mk*n*p - 4*f1_minus*mk*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n**2 + 8*mk*n*p + 4*n**2) - 4*mk*n + 4*mk*p - 4*n - 2*sqrt(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 12*f1_minus*mk*n**2 - 16*f1_minus*mk*n*p - 4*f1_minus*mk*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n**2 + 8*mk*n*p + 4*n**2))/(8*mk)
    tn = f1_minus*(-f1_minus*n - f1_minus*p + 6*mk*n + 2*mk*p + 2*n + sqrt(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 12*f1_minus*mk*n**2 - 16*f1_minus*mk*n*p - 4*f1_minus*mk*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n**2 + 8*mk*n*p + 4*n**2))/(8*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_f1_minus_mk_1(*, f1_minus, mk, p, n):
  """
  Solution of for the f1_minus - mk pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-f1_minus**2*n - f1_minus**2*p + 6*f1_minus*mk*n + 2*f1_minus*mk*p + 4*f1_minus*n + 2*f1_minus*p - f1_minus*sqrt(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 12*f1_minus*mk*n**2 - 16*f1_minus*mk*n*p - 4*f1_minus*mk*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n**2 + 8*mk*n*p + 4*n**2) - 4*mk*n + 4*mk*p - 4*n + 2*sqrt(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 12*f1_minus*mk*n**2 - 16*f1_minus*mk*n*p - 4*f1_minus*mk*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n**2 + 8*mk*n*p + 4*n**2))/(8*mk)
    tn = f1_minus*(-f1_minus*n - f1_minus*p + 6*mk*n + 2*mk*p + 2*n - sqrt(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 12*f1_minus*mk*n**2 - 16*f1_minus*mk*n*p - 4*f1_minus*mk*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mk**2*n**2 + 8*mk**2*n*p + 4*mk**2*p**2 + 8*mk*n**2 + 8*mk*n*p + 4*n**2))/(8*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_f1_minus_mk(*, f1_minus, mk, p, n):
  """
  Solution of for the f1_minus - mk pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_f1_minus_mk_0(f1_minus=f1_minus, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_f1_minus_mk_1(f1_minus=f1_minus, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_f1_minus_dor_0(*, f1_minus, dor, p, n):
  """
  Solution of for the f1_minus - dor pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor*f1_minus*n + dor*f1_minus*p - dor*n - f1_minus*n/2 - f1_minus*p/2 + sqrt(4*dor**2*f1_minus**2*n**2 - 8*dor**2*f1_minus*n**2 + 4*dor**2*n**2 - 4*dor*f1_minus**2*n**2 + 4*dor*f1_minus*n**2 - 4*dor*f1_minus*n*p + f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2)/2)/(f1_minus*(dor - 1))
    tn = (-2*dor*n + f1_minus*n + f1_minus*p + sqrt(4*dor**2*f1_minus**2*n**2 - 8*dor**2*f1_minus*n**2 + 4*dor**2*n**2 - 4*dor*f1_minus**2*n**2 + 4*dor*f1_minus*n**2 - 4*dor*f1_minus*n*p + f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2))/(2*(dor*f1_minus - 2*dor - f1_minus + 2))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_f1_minus_dor_1(*, f1_minus, dor, p, n):
  """
  Solution of for the f1_minus - dor pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor*f1_minus*n + dor*f1_minus*p - dor*n - f1_minus*n/2 - f1_minus*p/2 - sqrt(4*dor**2*f1_minus**2*n**2 - 8*dor**2*f1_minus*n**2 + 4*dor**2*n**2 - 4*dor*f1_minus**2*n**2 + 4*dor*f1_minus*n**2 - 4*dor*f1_minus*n*p + f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2)/2)/(f1_minus*(dor - 1))
    tn = (-2*dor*n + f1_minus*n + f1_minus*p - sqrt(4*dor**2*f1_minus**2*n**2 - 8*dor**2*f1_minus*n**2 + 4*dor**2*n**2 - 4*dor*f1_minus**2*n**2 + 4*dor*f1_minus*n**2 - 4*dor*f1_minus*n*p + f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2))/(2*(dor*f1_minus - 2*dor - f1_minus + 2))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_f1_minus_dor(*, f1_minus, dor, p, n):
  """
  Solution of for the f1_minus - dor pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_f1_minus_dor_0(f1_minus=f1_minus, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_f1_minus_dor_1(f1_minus=f1_minus, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_f1_minus_mcc_0(*, f1_minus, mcc, p, n):
  """
  Solution of for the f1_minus - mcc pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-n*(mcc*sqrt(-p*(2*f1_minus**2*n + f1_minus**2*p - 2*f1_minus*n - mcc**2*p))*(f1_minus - 2)*(n + p) - p*(f1_minus**2*n + f1_minus**2*p + 3*f1_minus*mcc**2*n + f1_minus*mcc**2*p - 2*f1_minus*n - 2*mcc**2*n - 2*mcc**2*p)) + p*(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mcc**2*n*p + 4*n**2))/(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mcc**2*n*p + 4*n**2)
    tn = f1_minus*n*(-f1_minus*n**2 - f1_minus*n*p + 3*mcc**2*n*p + mcc**2*p**2 - mcc*n*sqrt(p*(-2*f1_minus**2*n - f1_minus**2*p + 2*f1_minus*n + mcc**2*p)) - mcc*p*sqrt(p*(-2*f1_minus**2*n - f1_minus**2*p + 2*f1_minus*n + mcc**2*p)) + 2*n**2)/(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mcc**2*n*p + 4*n**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_f1_minus_mcc_1(*, f1_minus, mcc, p, n):
  """
  Solution of for the f1_minus - mcc pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (n*(mcc*sqrt(-p*(2*f1_minus**2*n + f1_minus**2*p - 2*f1_minus*n - mcc**2*p))*(f1_minus - 2)*(n + p) + p*(f1_minus**2*n + f1_minus**2*p + 3*f1_minus*mcc**2*n + f1_minus*mcc**2*p - 2*f1_minus*n - 2*mcc**2*n - 2*mcc**2*p)) + p*(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mcc**2*n*p + 4*n**2))/(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mcc**2*n*p + 4*n**2)
    tn = f1_minus*n*(-f1_minus*n**2 - f1_minus*n*p + 3*mcc**2*n*p + mcc**2*p**2 + mcc*n*sqrt(p*(-2*f1_minus**2*n - f1_minus**2*p + 2*f1_minus*n + mcc**2*p)) + mcc*p*sqrt(p*(-2*f1_minus**2*n - f1_minus**2*p + 2*f1_minus*n + mcc**2*p)) + 2*n**2)/(f1_minus**2*n**2 + 2*f1_minus**2*n*p + f1_minus**2*p**2 - 4*f1_minus*n**2 - 4*f1_minus*n*p + 4*mcc**2*n*p + 4*n**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_f1_minus_mcc(*, f1_minus, mcc, p, n):
  """
  Solution of for the f1_minus - mcc pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_f1_minus_mcc_0(f1_minus=f1_minus, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_f1_minus_mcc_1(f1_minus=f1_minus, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_f1_minus_ji(*, f1_minus, ji, p, n):
  """
  Solution of for the f1_minus - ji pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2*f1_minus*ji*n + 2*f1_minus*ji*p - 2*ji*n - 2*ji*p)/(f1_minus*ji + f1_minus - 2)
    tn = (f1_minus*ji*n + f1_minus*ji*p - f1_minus*n - f1_minus*p)/(f1_minus*ji + f1_minus - 2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_f1_minus_ba(*, f1_minus, ba, p, n):
  """
  Solution of for the f1_minus - ba pair

  Args:
    f1_minus (int/float/Interval): the f1_minus score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2.0*ba*f1_minus*n*p - 4.0*ba*n*p + f1_minus*n*p + f1_minus*p**2)/(f1_minus*n + f1_minus*p - 2.0*n)
    tn = (2.0*ba*f1_minus*n*p - f1_minus*n**2 - f1_minus*n*p)/(f1_minus*n + f1_minus*p - 2.0*n)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_fm_bm_0(*, fm, bm, p, n):
  """
  Solution of for the fm - bm pair

  Args:
    fm (int/float/Interval): the fm score
    bm (int/float/Interval): the bm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(fm*n + fm*p + sqrt(-4*bm*n*p + fm**2*n**2 + 2*fm**2*n*p + fm**2*p**2))/2
    tn = n*(2*bm*p - fm**2*n - fm**2*p - fm*sqrt(-4*bm*n*p + fm**2*n**2 + 2*fm**2*n*p + fm**2*p**2) + 2*p)/(2*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_bm_1(*, fm, bm, p, n):
  """
  Solution of for the fm - bm pair

  Args:
    fm (int/float/Interval): the fm score
    bm (int/float/Interval): the bm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(fm*n + fm*p - sqrt(-4*bm*n*p + fm**2*n**2 + 2*fm**2*n*p + fm**2*p**2))/2
    tn = n*(2*bm*p - fm**2*n - fm**2*p + fm*sqrt(-4*bm*n*p + fm**2*n**2 + 2*fm**2*n*p + fm**2*p**2) + 2*p)/(2*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_fm_bm(*, fm, bm, p, n):
  """
  Solution of for the fm - bm pair

  Args:
    fm (int/float/Interval): the fm score
    bm (int/float/Interval): the bm score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_fm_bm_0(fm=fm, bm=bm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_bm_1(fm=fm, bm=bm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_fm_pt_0(*, n):
  """
  Solution of for the fm - pt pair

  Args:
    fm (int/float/Interval): the fm score
    pt (int/float/Interval): the pt score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_pt_1(*, fm, pt, p, n):
  """
  Solution of for the fm - pt pair

  Args:
    fm (int/float/Interval): the fm score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm**2*(n*pt**2 + p*pt**2 - 2*p*pt + p)/(pt**2 - 2*pt + 1)
    tn = n*(-fm**2*n*pt**4 - fm**2*p*pt**4 + 2*fm**2*p*pt**3 - fm**2*p*pt**2 + p*pt**4 - 4*p*pt**3 + 6*p*pt**2 - 4*p*pt + p)/(p*(pt**4 - 4*pt**3 + 6*pt**2 - 4*pt + 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_pt_2(*, fm, p, n):
  """
  Solution of for the fm - pt pair

  Args:
    fm (int/float/Interval): the fm score
    pt (int/float/Interval): the pt score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm**2*(n + p)
    tn = n*(-fm**2*n - fm**2*p + p)/p
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_fm_pt(*, fm, pt, p, n):
  """
  Solution of for the fm - pt pair

  Args:
    fm (int/float/Interval): the fm score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_fm_pt_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_pt_1(fm=fm, pt=pt, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_pt_2(fm=fm, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_fm_lrp_0(*, n):
  """
  Solution of for the fm - lrp pair

  Args:
    fm (int/float/Interval): the fm score
    lrp (int/float/Interval): the lrp score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_lrp_1(*, fm, lrp, p, n):
  """
  Solution of for the fm - lrp pair

  Args:
    fm (int/float/Interval): the fm score
    lrp (int/float/Interval): the lrp score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm**2*(lrp*p + n)/lrp
    tn = -n*(fm**2*lrp*p + fm**2*n - lrp**2*p)/(lrp**2*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_fm_lrp(*, fm, lrp, p, n):
  """
  Solution of for the fm - lrp pair

  Args:
    fm (int/float/Interval): the fm score
    lrp (int/float/Interval): the lrp score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_fm_lrp_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_lrp_1(fm=fm, lrp=lrp, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_fm_lrn_0(*, fm, lrn, p, n):
  """
  Solution of for the fm - lrn pair

  Args:
    fm (int/float/Interval): the fm score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(fm*lrn*p + fm*n + sqrt(fm**2*lrn**2*p**2 + 2*fm**2*lrn*n*p + fm**2*n**2 + 4*lrn**2*n*p - 4*lrn*n*p))/(2*lrn)
    tn = n*(-fm**2*lrn*p - fm**2*n - fm*sqrt(fm**2*lrn**2*p**2 + 2*fm**2*lrn*n*p + fm**2*n**2 + 4*lrn**2*n*p - 4*lrn*n*p) + 2*lrn*p)/(2*lrn**2*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_lrn_1(*, fm, lrn, p, n):
  """
  Solution of for the fm - lrn pair

  Args:
    fm (int/float/Interval): the fm score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(fm*lrn*p + fm*n - sqrt(fm**2*lrn**2*p**2 + 2*fm**2*lrn*n*p + fm**2*n**2 + 4*lrn**2*n*p - 4*lrn*n*p))/(2*lrn)
    tn = n*(-fm**2*lrn*p - fm**2*n + fm*sqrt(fm**2*lrn**2*p**2 + 2*fm**2*lrn*n*p + fm**2*n**2 + 4*lrn**2*n*p - 4*lrn*n*p) + 2*lrn*p)/(2*lrn**2*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_fm_lrn(*, fm, lrn, p, n):
  """
  Solution of for the fm - lrn pair

  Args:
    fm (int/float/Interval): the fm score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_fm_lrn_0(fm=fm, lrn=lrn, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_lrn_1(fm=fm, lrn=lrn, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_fm_dor_0(*, n):
  """
  Solution of for the fm - dor pair

  Args:
    fm (int/float/Interval): the fm score
    dor (int/float/Interval): the dor score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_dor_1(*, fm, dor, p, n):
  """
  Solution of for the fm - dor pair

  Args:
    fm (int/float/Interval): the fm score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor*fm**2*p + dor*p - fm**2*p + sqrt(p*(dor**2*fm**4*p - 2*dor**2*fm**2*p + dor**2*p - 2*dor*fm**4*p - 4*dor*fm**2*n + 2*dor*fm**2*p + fm**4*p + 4*fm**2*n)))/(2*(dor - 1))
    tn = dor*(2*dor*fm**2*n + dor*fm**2*p - dor*p - 2*fm**2*n - fm**2*p - sqrt(p*(dor**2*fm**4*p - 2*dor**2*fm**2*p + dor**2*p - 2*dor*fm**4*p - 4*dor*fm**2*n + 2*dor*fm**2*p + fm**4*p + 4*fm**2*n)))/(2*fm**2*(dor**2 - 2*dor + 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_dor_2(*, fm, dor, p, n):
  """
  Solution of for the fm - dor pair

  Args:
    fm (int/float/Interval): the fm score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor*fm**2*p + dor*p - fm**2*p - sqrt(p*(dor**2*fm**4*p - 2*dor**2*fm**2*p + dor**2*p - 2*dor*fm**4*p - 4*dor*fm**2*n + 2*dor*fm**2*p + fm**4*p + 4*fm**2*n)))/(2*(dor - 1))
    tn = dor*(2*dor*fm**2*n + dor*fm**2*p - dor*p - 2*fm**2*n - fm**2*p + sqrt(p*(dor**2*fm**4*p - 2*dor**2*fm**2*p + dor**2*p - 2*dor*fm**4*p - 4*dor*fm**2*n + 2*dor*fm**2*p + fm**4*p + 4*fm**2*n)))/(2*fm**2*(dor**2 - 2*dor + 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_fm_dor(*, fm, dor, p, n):
  """
  Solution of for the fm - dor pair

  Args:
    fm (int/float/Interval): the fm score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_fm_dor_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_dor_1(fm=fm, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_dor_2(fm=fm, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_fm_mcc_0(*, n):
  """
  Solution of for the fm - mcc pair

  Args:
    fm (int/float/Interval): the fm score
    mcc (int/float/Interval): the mcc score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_mcc_1(*, fm, mcc, p, n):
  """
  Solution of for the fm - mcc pair

  Args:
    fm (int/float/Interval): the fm score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(fm*p*(n + p) - mcc*sqrt(-n*p*(n + p)*(fm**2*n + fm**2*p - mcc**2*n - p)))/(mcc**2*n + p)
    tn = (fm*p*(mcc**2*n + p)*(fm*p*(n + p) - mcc*sqrt(-n*p*(n + p)*(fm**2*n + fm**2*p - mcc**2*n - p))) + n*p*(mcc**2*n + p)**2 - (fm*p*(n + p) - mcc*sqrt(-n*p*(n + p)*(fm**2*n + fm**2*p - mcc**2*n - p)))**2)/(p*(mcc**2*n + p)**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_mcc_2(*, fm, mcc, p, n):
  """
  Solution of for the fm - mcc pair

  Args:
    fm (int/float/Interval): the fm score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*(fm*p*(n + p) + mcc*sqrt(-n*p*(n + p)*(fm**2*n + fm**2*p - mcc**2*n - p)))/(mcc**2*n + p)
    tn = (fm*p*(mcc**2*n + p)*(fm*p*(n + p) + mcc*sqrt(-n*p*(n + p)*(fm**2*n + fm**2*p - mcc**2*n - p))) + n*p*(mcc**2*n + p)**2 - (fm*p*(n + p) + mcc*sqrt(-n*p*(n + p)*(fm**2*n + fm**2*p - mcc**2*n - p)))**2)/(p*(mcc**2*n + p)**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_fm_mcc(*, fm, mcc, p, n):
  """
  Solution of for the fm - mcc pair

  Args:
    fm (int/float/Interval): the fm score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_fm_mcc_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_mcc_1(fm=fm, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_mcc_2(fm=fm, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_fm_ji_0(*, fm, ji, p, n):
  """
  Solution of for the fm - ji pair

  Args:
    fm (int/float/Interval): the fm score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*p*(fm*ji + fm + sqrt(fm**2*ji**2 + 2*fm**2*ji + fm**2 - 4*ji**2))/(2*ji)
    tn = -fm**2*p/(2*ji) - fm**2*p/(2*ji**2) - fm*p*sqrt(fm**2*ji**2 + 2*fm**2*ji + fm**2 - 4*ji**2)/(2*ji**2) + n + p
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_ji_1(*, fm, ji, p, n):
  """
  Solution of for the fm - ji pair

  Args:
    fm (int/float/Interval): the fm score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = fm*p*(fm*ji + fm - sqrt(fm**2*ji**2 + 2*fm**2*ji + fm**2 - 4*ji**2))/(2*ji)
    tn = -fm**2*p/(2*ji) - fm**2*p/(2*ji**2) + fm*p*sqrt(fm**2*ji**2 + 2*fm**2*ji + fm**2 - 4*ji**2)/(2*ji**2) + n + p
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_fm_ji(*, fm, ji, p, n):
  """
  Solution of for the fm - ji pair

  Args:
    fm (int/float/Interval): the fm score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_fm_ji_0(fm=fm, ji=ji, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_ji_1(fm=fm, ji=ji, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_fm_ba_0(*, fm, ba, p, n):
  """
  Solution of for the fm - ba pair

  Args:
    fm (int/float/Interval): the fm score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0.5*fm*(fm*n + fm*p + 2.82842712474619*sqrt(-ba*n*p + 0.125*fm**2*n**2 + 0.25*fm**2*n*p + 0.125*fm**2*p**2 + 0.5*n*p))
    tn = 0.5*n*(4.0*ba*p - fm**2*n - fm**2*p - 2.82842712474619*fm*sqrt(-ba*n*p + 0.125*fm**2*n**2 + 0.25*fm**2*n*p + 0.125*fm**2*p**2 + 0.5*n*p))/p
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_fm_ba_1(*, fm, ba, p, n):
  """
  Solution of for the fm - ba pair

  Args:
    fm (int/float/Interval): the fm score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0.5*fm*(fm*n + fm*p - 2.82842712474619*sqrt(-ba*n*p + 0.125*fm**2*n**2 + 0.25*fm**2*n*p + 0.125*fm**2*p**2 + 0.5*n*p))
    tn = 0.5*n*(4.0*ba*p - fm**2*n - fm**2*p + 2.82842712474619*fm*sqrt(-ba*n*p + 0.125*fm**2*n**2 + 0.25*fm**2*n*p + 0.125*fm**2*p**2 + 0.5*n*p))/p
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_fm_ba(*, fm, ba, p, n):
  """
  Solution of for the fm - ba pair

  Args:
    fm (int/float/Interval): the fm score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_fm_ba_0(fm=fm, ba=ba, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_fm_ba_1(fm=fm, ba=ba, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_bm_pt(*, bm, pt, p, n):
  """
  Solution of for the bm - pt pair

  Args:
    bm (int/float/Interval): the bm score
    pt (int/float/Interval): the pt score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = bm*p*(-pt**2 + 2*pt - 1)/(2*pt - 1)
    tn = n*(bm*pt**2 + 2*pt - 1)/(2*pt - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_bm_lrp(*, bm, lrp, p, n):
  """
  Solution of for the bm - lrp pair

  Args:
    bm (int/float/Interval): the bm score
    lrp (int/float/Interval): the lrp score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = bm*lrp*p/(lrp - 1)
    tn = (-bm*n + lrp*n - n)/(lrp - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_bm_lrn(*, bm, lrn, p, n):
  """
  Solution of for the bm - lrn pair

  Args:
    bm (int/float/Interval): the bm score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (bm*lrn*p + lrn*p - p)/(lrn - 1)
    tn = -bm*n/(lrn - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_bm_mk_0(*, bm, mk, p, n):
  """
  Solution of for the bm - mk pair

  Args:
    bm (int/float/Interval): the bm score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(2*bm*mk*n + mk*n + mk*p + sqrt(mk*(-4*bm*n*p + mk*n**2 + 2*mk*n*p + mk*p**2)))/(2*mk*(n + p))
    tn = n*(2*bm*mk*p + mk*n + mk*p - sqrt(mk*(-4*bm*n*p + mk*n**2 + 2*mk*n*p + mk*p**2)))/(2*mk*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_bm_mk_1(*, bm, mk, p, n):
  """
  Solution of for the bm - mk pair

  Args:
    bm (int/float/Interval): the bm score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(2*bm*mk*n + mk*n + mk*p - sqrt(mk*(-4*bm*n*p + mk*n**2 + 2*mk*n*p + mk*p**2)))/(2*mk*(n + p))
    tn = n*(2*bm*mk*p + mk*n + mk*p + sqrt(mk*(-4*bm*n*p + mk*n**2 + 2*mk*n*p + mk*p**2)))/(2*mk*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_bm_mk(*, bm, mk, p, n):
  """
  Solution of for the bm - mk pair

  Args:
    bm (int/float/Interval): the bm score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_bm_mk_0(bm=bm, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_bm_mk_1(bm=bm, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_bm_dor_0(*, bm, dor, p, n):
  """
  Solution of for the bm - dor pair

  Args:
    bm (int/float/Interval): the bm score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(bm*dor - bm + dor + sqrt(bm**2*dor**2 - 2*bm**2*dor + bm**2 - 2*bm*dor**2 + 2*bm + dor**2 - 2*dor + 1) - 1)/(2*(dor - 1))
    tn = n*(bm*dor - bm + dor - sqrt(bm**2*dor**2 - 2*bm**2*dor + bm**2 - 2*bm*dor**2 + 2*bm + dor**2 - 2*dor + 1) - 1)/(2*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_bm_dor_1(*, bm, dor, p, n):
  """
  Solution of for the bm - dor pair

  Args:
    bm (int/float/Interval): the bm score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(bm*dor - bm + dor - sqrt(bm**2*dor**2 - 2*bm**2*dor + bm**2 - 2*bm*dor**2 + 2*bm + dor**2 - 2*dor + 1) - 1)/(2*(dor - 1))
    tn = n*(bm*dor - bm + dor + sqrt(bm**2*dor**2 - 2*bm**2*dor + bm**2 - 2*bm*dor**2 + 2*bm + dor**2 - 2*dor + 1) - 1)/(2*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_bm_dor(*, bm, dor, p, n):
  """
  Solution of for the bm - dor pair

  Args:
    bm (int/float/Interval): the bm score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_bm_dor_0(bm=bm, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_bm_dor_1(bm=bm, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_bm_mcc_0(*, bm, mcc, p, n):
  """
  Solution of for the bm - mcc pair

  Args:
    bm (int/float/Interval): the bm score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2*bm*n**2*p + n**2*p + n*p**2 + sqrt(n**2*p**2*(-4*bm**2*n*p + mcc**2*n**2 + 2*mcc**2*n*p + mcc**2*p**2)/mcc**2))/(2*n*(n + p))
    tn = (2*bm*n*p**2 + n**2*p + n*p**2 - sqrt(n**2*p**2*(-4*bm**2*n*p + mcc**2*n**2 + 2*mcc**2*n*p + mcc**2*p**2)/mcc**2))/(2*p*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_bm_mcc_1(*, bm, mcc, p, n):
  """
  Solution of for the bm - mcc pair

  Args:
    bm (int/float/Interval): the bm score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2*bm*n**2*p + n**2*p + n*p**2 - sqrt(n**2*p**2*(-4*bm**2*n*p + mcc**2*n**2 + 2*mcc**2*n*p + mcc**2*p**2)/mcc**2))/(2*n*(n + p))
    tn = (2*bm*n*p**2 + n**2*p + n*p**2 + sqrt(n**2*p**2*(-4*bm**2*n*p + mcc**2*n**2 + 2*mcc**2*n*p + mcc**2*p**2)/mcc**2))/(2*p*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_bm_mcc(*, bm, mcc, p, n):
  """
  Solution of for the bm - mcc pair

  Args:
    bm (int/float/Interval): the bm score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_bm_mcc_0(bm=bm, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_bm_mcc_1(bm=bm, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_bm_ji(*, bm, ji, p, n):
  """
  Solution of for the bm - ji pair

  Args:
    bm (int/float/Interval): the bm score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-bm*ji*n*p + ji*p**2)/(-ji*n + p)
    tn = (bm*n*p - ji*n**2 - ji*n*p + n*p)/(-ji*n + p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_pt_lrn_0(*, p):
  """
  Solution of for the pt - lrn pair

  Args:
    pt (int/float/Interval): the pt score
    lrn (int/float/Interval): the lrn score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_lrn_1(*, pt, lrn, p, n):
  """
  Solution of for the pt - lrn pair

  Args:
    pt (int/float/Interval): the pt score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(lrn*pt**2 - lrn*(2*pt - 1) - pt**2 + 2*pt - 1)/(lrn*pt**2 - pt**2 + 2*pt - 1)
    tn = n*(2*pt - 1)/(lrn*pt**2 - pt**2 + 2*pt - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_pt_lrn(*, pt, lrn, p, n):
  """
  Solution of for the pt - lrn pair

  Args:
    pt (int/float/Interval): the pt score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_pt_lrn_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_lrn_1(pt=pt, lrn=lrn, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_pt_mk_0(*, mk, p, n):
  """
  Solution of for the pt - mk pair

  Args:
    pt (int/float/Interval): the pt score
    mk (int/float/Interval): the mk score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = (mk*n + mk*p - p + sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 - 2*mk*n*p - 2*mk*p**2 + p**2))/(2*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_mk_1(*, mk, p, n):
  """
  Solution of for the pt - mk pair

  Args:
    pt (int/float/Interval): the pt score
    mk (int/float/Interval): the mk score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = (mk*n + mk*p - p - sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 - 2*mk*n*p - 2*mk*p**2 + p**2))/(2*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_mk_2(*, mk, p, n):
  """
  Solution of for the pt - mk pair

  Args:
    pt (int/float/Interval): the pt score
    mk (int/float/Interval): the mk score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = (mk*n - mk*p - p + sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(2*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_mk_3(*, mk, p, n):
  """
  Solution of for the pt - mk pair

  Args:
    pt (int/float/Interval): the pt score
    mk (int/float/Interval): the mk score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = (mk*n - mk*p - p - sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(2*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_mk_4(*, pt, mk, p, n):
  """
  Solution of for the pt - mk pair

  Args:
    pt (int/float/Interval): the pt score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(mk*n**2*pt**4 - 2*mk*n**2*pt**3 + mk*n**2*pt**2 + 2*mk*n*p*pt**4 - 6*mk*n*p*pt**3 + 7*mk*n*p*pt**2 - 4*mk*n*p*pt + mk*n*p + mk*p**2*pt**4 - 4*mk*p**2*pt**3 + 6*mk*p**2*pt**2 - 4*mk*p**2*pt + mk*p**2 + 2*n*p*pt**3 - 5*n*p*pt**2 + 4*n*p*pt - n*p)/(mk*(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2))
    tn = (2*p*(mk*n**2*pt**4 - 2*mk*n**2*pt**3 + mk*n**2*pt**2 + 2*mk*n*p*pt**4 - 6*mk*n*p*pt**3 + 7*mk*n*p*pt**2 - 4*mk*n*p*pt + mk*n*p + mk*p**2*pt**4 - 4*mk*p**2*pt**3 + 6*mk*p**2*pt**2 - 4*mk*p**2*pt + mk*p**2 + 2*n*p*pt**3 - 5*n*p*pt**2 + 4*n*p*pt - n*p) + sqrt((-4*n*p*(mk*n**2*pt**4 - 2*mk*n**2*pt**3 + mk*n**2*pt**2 + 2*mk*n*p*pt**4 - 6*mk*n*p*pt**3 + 7*mk*n*p*pt**2 - 4*mk*n*p*pt + mk*n*p + mk*p**2*pt**4 - 4*mk*p**2*pt**3 + 6*mk*p**2*pt**2 - 4*mk*p**2*pt + mk*p**2 + 2*n*p*pt**3 - 5*n*p*pt**2 + 4*n*p*pt - n*p) - 4*p**2*(mk*n**2*pt**4 - 2*mk*n**2*pt**3 + mk*n**2*pt**2 + 2*mk*n*p*pt**4 - 6*mk*n*p*pt**3 + 7*mk*n*p*pt**2 - 4*mk*n*p*pt + mk*n*p + mk*p**2*pt**4 - 4*mk*p**2*pt**3 + 6*mk*p**2*pt**2 - 4*mk*p**2*pt + mk*p**2 + 2*n*p*pt**3 - 5*n*p*pt**2 + 4*n*p*pt - n*p) + (mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2)*(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2))/(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2))*(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2) + (mk*n - mk*p - p)*(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2))/(2*mk*(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_mk_5(*, pt, mk, p, n):
  """
  Solution of for the pt - mk pair

  Args:
    pt (int/float/Interval): the pt score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(mk*n**2*pt**4 - 2*mk*n**2*pt**3 + mk*n**2*pt**2 + 2*mk*n*p*pt**4 - 6*mk*n*p*pt**3 + 7*mk*n*p*pt**2 - 4*mk*n*p*pt + mk*n*p + mk*p**2*pt**4 - 4*mk*p**2*pt**3 + 6*mk*p**2*pt**2 - 4*mk*p**2*pt + mk*p**2 + 2*n*p*pt**3 - 5*n*p*pt**2 + 4*n*p*pt - n*p)/(mk*(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2))
    tn = (2*p*(mk*n**2*pt**4 - 2*mk*n**2*pt**3 + mk*n**2*pt**2 + 2*mk*n*p*pt**4 - 6*mk*n*p*pt**3 + 7*mk*n*p*pt**2 - 4*mk*n*p*pt + mk*n*p + mk*p**2*pt**4 - 4*mk*p**2*pt**3 + 6*mk*p**2*pt**2 - 4*mk*p**2*pt + mk*p**2 + 2*n*p*pt**3 - 5*n*p*pt**2 + 4*n*p*pt - n*p) - sqrt((-4*n*p*(mk*n**2*pt**4 - 2*mk*n**2*pt**3 + mk*n**2*pt**2 + 2*mk*n*p*pt**4 - 6*mk*n*p*pt**3 + 7*mk*n*p*pt**2 - 4*mk*n*p*pt + mk*n*p + mk*p**2*pt**4 - 4*mk*p**2*pt**3 + 6*mk*p**2*pt**2 - 4*mk*p**2*pt + mk*p**2 + 2*n*p*pt**3 - 5*n*p*pt**2 + 4*n*p*pt - n*p) - 4*p**2*(mk*n**2*pt**4 - 2*mk*n**2*pt**3 + mk*n**2*pt**2 + 2*mk*n*p*pt**4 - 6*mk*n*p*pt**3 + 7*mk*n*p*pt**2 - 4*mk*n*p*pt + mk*n*p + mk*p**2*pt**4 - 4*mk*p**2*pt**3 + 6*mk*p**2*pt**2 - 4*mk*p**2*pt + mk*p**2 + 2*n*p*pt**3 - 5*n*p*pt**2 + 4*n*p*pt - n*p) + (mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2)*(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2))/(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2))*(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2) + (mk*n - mk*p - p)*(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2))/(2*mk*(n**2*pt**4 + 2*n*p*pt**4 - 4*n*p*pt**3 + 2*n*p*pt**2 + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_pt_mk(*, pt, mk, p, n):
  """
  Solution of for the pt - mk pair

  Args:
    pt (int/float/Interval): the pt score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_pt_mk_0(mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_mk_1(mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_mk_2(mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_mk_3(mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_mk_4(pt=pt, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_mk_5(pt=pt, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_pt_dor_0(*, p):
  """
  Solution of for the pt - dor pair

  Args:
    pt (int/float/Interval): the pt score
    dor (int/float/Interval): the dor score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_dor_1(*, n):
  """
  Solution of for the pt - dor pair

  Args:
    pt (int/float/Interval): the pt score
    dor (int/float/Interval): the dor score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_dor_2(*, pt, dor, p, n):
  """
  Solution of for the pt - dor pair

  Args:
    pt (int/float/Interval): the pt score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(dor*pt**2 - pt**2 + 2*pt - 1)/(pt**2*(dor - 1))
    tn = dor*n*(1 - 2*pt)/(dor*pt**2 - 2*dor*pt + dor - pt**2 + 2*pt - 1)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_pt_dor(*, pt, dor, p, n):
  """
  Solution of for the pt - dor pair

  Args:
    pt (int/float/Interval): the pt score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_pt_dor_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_dor_1(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_dor_2(pt=pt, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_pt_mcc_0(*, n):
  """
  Solution of for the pt - mcc pair

  Args:
    pt (int/float/Interval): the pt score
    mcc (int/float/Interval): the mcc score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_mcc_1(*, p, n):
  """
  Solution of for the pt - mcc pair

  Args:
    pt (int/float/Interval): the pt score
    mcc (int/float/Interval): the mcc score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (n**2*p + n*p**2 + sqrt(n**2*p**2*(n**2 + 2*n*p + p**2)))/(2*n*(n + p))
    tn = (n**2*p + n*p**2 - sqrt(n**2*p**2*(n**2 + 2*n*p + p**2)))/(2*p*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_mcc_2(*, p, n):
  """
  Solution of for the pt - mcc pair

  Args:
    pt (int/float/Interval): the pt score
    mcc (int/float/Interval): the mcc score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (n**2*p + n*p**2 - sqrt(n**2*p**2*(n**2 + 2*n*p + p**2)))/(2*n*(n + p))
    tn = (n**2*p + n*p**2 + sqrt(n**2*p**2*(n**2 + 2*n*p + p**2)))/(2*p*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_mcc_3(*, pt, mcc, p, n):
  """
  Solution of for the pt - mcc pair

  Args:
    pt (int/float/Interval): the pt score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = mcc**2*p*(n**2*pt**4 - 2*n**2*pt**3 + n**2*pt**2 + 2*n*p*pt**4 - 6*n*p*pt**3 + 7*n*p*pt**2 - 4*n*p*pt + n*p + p**2*pt**4 - 4*p**2*pt**3 + 6*p**2*pt**2 - 4*p**2*pt + p**2)/(mcc**2*n**2*pt**4 + 2*mcc**2*n*p*pt**4 - 4*mcc**2*n*p*pt**3 + 2*mcc**2*n*p*pt**2 + mcc**2*p**2*pt**4 - 4*mcc**2*p**2*pt**3 + 6*mcc**2*p**2*pt**2 - 4*mcc**2*p**2*pt + mcc**2*p**2 + 4*n*p*pt**2 - 4*n*p*pt + n*p)
    tn = n*p*(-2*mcc**2*n*pt**3 + mcc**2*n*pt**2 - 2*mcc**2*p*pt**3 + 5*mcc**2*p*pt**2 - 4*mcc**2*p*pt + mcc**2*p + 4*n*pt**2 - 4*n*pt + n)/(mcc**2*n**2*pt**4 + 2*mcc**2*n*p*pt**4 - 4*mcc**2*n*p*pt**3 + 2*mcc**2*n*p*pt**2 + mcc**2*p**2*pt**4 - 4*mcc**2*p**2*pt**3 + 6*mcc**2*p**2*pt**2 - 4*mcc**2*p**2*pt + mcc**2*p**2 + 4*n*p*pt**2 - 4*n*p*pt + n*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_pt_mcc(*, pt, mcc, p, n):
  """
  Solution of for the pt - mcc pair

  Args:
    pt (int/float/Interval): the pt score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_pt_mcc_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_mcc_1(p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_mcc_2(p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_mcc_3(pt=pt, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_pt_ji_0(*, ji, p, n):
  """
  Solution of for the pt - ji pair

  Args:
    pt (int/float/Interval): the pt score
    ji (int/float/Interval): the ji score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = ji*p**2/(-ji*n + p)
    tn = n*(ji*n + ji*p - p)/(ji*n - p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_pt_ji_1(*, pt, ji, p, n):
  """
  Solution of for the pt - ji pair

  Args:
    pt (int/float/Interval): the pt score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = ji*p**2*(pt**2 - 2*pt + 1)/(-ji*n*pt**2 + p*pt**2 - 2*p*pt + p)
    tn = n*(-ji*n*pt**2 - ji*p*pt**2 + p*pt**2 - 2*p*pt + p)/(-ji*n*pt**2 + p*pt**2 - 2*p*pt + p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_pt_ji(*, pt, ji, p, n):
  """
  Solution of for the pt - ji pair

  Args:
    pt (int/float/Interval): the pt score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_pt_ji_0(ji=ji, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_pt_ji_1(pt=pt, ji=ji, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_pt_ba(*, pt, ba, p, n):
  """
  Solution of for the pt - ba pair

  Args:
    pt (int/float/Interval): the pt score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(-2.0*ba*pt**2 + 4.0*ba*pt - 2.0*ba + pt**2 - 2.0*pt + 1.0)/(2.0*pt - 1.0)
    tn = n*(2.0*ba*pt**2 - pt**2 + 2.0*pt - 1.0)/(2.0*pt - 1.0)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_lrp_lrn(*, lrp, lrn, p, n):
  """
  Solution of for the lrp - lrn pair

  Args:
    lrp (int/float/Interval): the lrp score
    lrn (int/float/Interval): the lrn score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (lrn*lrp*p - lrp*p)/(lrn - lrp)
    tn = (-lrp*n + n)/(lrn - lrp)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_lrp_mk_0(*, n):
  """
  Solution of for the lrp - mk pair

  Args:
    lrp (int/float/Interval): the lrp score
    mk (int/float/Interval): the mk score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_lrp_mk_1(*, lrp, mk, p, n):
  """
  Solution of for the lrp - mk pair

  Args:
    lrp (int/float/Interval): the lrp score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = lrp*p*(lrp*mk*n*p + lrp*mk*p**2 - lrp*n*p + mk*n**2 + mk*n*p + n*p)/(mk*(lrp*p + n)**2)
    tn = n*p*(lrp - 1)*(lrp*mk*p + mk*n + n)/(mk*(lrp*p + n)**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_lrp_mk(*, lrp, mk, p, n):
  """
  Solution of for the lrp - mk pair

  Args:
    lrp (int/float/Interval): the lrp score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_lrp_mk_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_lrp_mk_1(lrp=lrp, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_lrp_dor_0(*, n):
  """
  Solution of for the lrp - dor pair

  Args:
    lrp (int/float/Interval): the lrp score
    dor (int/float/Interval): the dor score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_lrp_dor_1(*, lrp, dor, p, n):
  """
  Solution of for the lrp - dor pair

  Args:
    lrp (int/float/Interval): the lrp score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(dor - lrp)/(dor - 1)
    tn = dor*n*(lrp - 1)/(lrp*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_lrp_dor(*, lrp, dor, p, n):
  """
  Solution of for the lrp - dor pair

  Args:
    lrp (int/float/Interval): the lrp score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_lrp_dor_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_lrp_dor_1(lrp=lrp, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_lrp_mcc_0(*, n):
  """
  Solution of for the lrp - mcc pair

  Args:
    lrp (int/float/Interval): the lrp score
    mcc (int/float/Interval): the mcc score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_lrp_mcc_1(*, lrp, mcc, p, n):
  """
  Solution of for the lrp - mcc pair

  Args:
    lrp (int/float/Interval): the lrp score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = lrp*mcc**2*p*(lrp*n*p + lrp*p**2 + n**2 + n*p)/(lrp**2*mcc**2*p**2 + lrp**2*n*p + 2*lrp*mcc**2*n*p - 2*lrp*n*p + mcc**2*n**2 + n*p)
    tn = n*p*(lrp**2*mcc**2*p + lrp**2*n + lrp*mcc**2*n - lrp*mcc**2*p - 2*lrp*n - mcc**2*n + n)/(lrp**2*mcc**2*p**2 + lrp**2*n*p + 2*lrp*mcc**2*n*p - 2*lrp*n*p + mcc**2*n**2 + n*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_lrp_mcc(*, lrp, mcc, p, n):
  """
  Solution of for the lrp - mcc pair

  Args:
    lrp (int/float/Interval): the lrp score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_lrp_mcc_0(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_lrp_mcc_1(lrp=lrp, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_lrp_ji(*, lrp, ji, p, n):
  """
  Solution of for the lrp - ji pair

  Args:
    lrp (int/float/Interval): the lrp score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = ji*lrp*p**2/(-ji*n + lrp*p)
    tn = (-ji*n**2 - ji*n*p + lrp*n*p)/(-ji*n + lrp*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_lrp_ba(*, lrp, ba, p, n):
  """
  Solution of for the lrp - ba pair

  Args:
    lrp (int/float/Interval): the lrp score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2.0*ba*lrp*p - lrp*p)/(lrp - 1.0)
    tn = (-2.0*ba*n + lrp*n)/(lrp - 1.0)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_lrn_mk_0(*, p):
  """
  Solution of for the lrn - mk pair

  Args:
    lrn (int/float/Interval): the lrn score
    mk (int/float/Interval): the mk score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_lrn_mk_1(*, lrn, mk, p, n):
  """
  Solution of for the lrn - mk pair

  Args:
    lrn (int/float/Interval): the lrn score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = -n*p*(lrn - 1)*(lrn*mk*p + lrn*p + mk*n)/(mk*(lrn*p + n)**2)
    tn = n*(lrn*mk*n*p + lrn*mk*p**2 + lrn*n*p + mk*n**2 + mk*n*p - n*p)/(mk*(lrn*p + n)**2)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_lrn_mk(*, lrn, mk, p, n):
  """
  Solution of for the lrn - mk pair

  Args:
    lrn (int/float/Interval): the lrn score
    mk (int/float/Interval): the mk score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_lrn_mk_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_lrn_mk_1(lrn=lrn, mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_lrn_dor_0(*, p):
  """
  Solution of for the lrn - dor pair

  Args:
    lrn (int/float/Interval): the lrn score
    dor (int/float/Interval): the dor score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_lrn_dor_1(*, lrn, dor, p, n):
  """
  Solution of for the lrn - dor pair

  Args:
    lrn (int/float/Interval): the lrn score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = -dor*p*(lrn - 1)/(dor - 1)
    tn = n*(dor*lrn - 1)/(lrn*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_lrn_dor(*, lrn, dor, p, n):
  """
  Solution of for the lrn - dor pair

  Args:
    lrn (int/float/Interval): the lrn score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_lrn_dor_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_lrn_dor_1(lrn=lrn, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_lrn_mcc_0(*, p):
  """
  Solution of for the lrn - mcc pair

  Args:
    lrn (int/float/Interval): the lrn score
    mcc (int/float/Interval): the mcc score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_lrn_mcc_1(*, lrn, mcc, p, n):
  """
  Solution of for the lrn - mcc pair

  Args:
    lrn (int/float/Interval): the lrn score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = n*p*(-lrn**2*mcc**2*p + lrn**2*p - lrn*mcc**2*n + lrn*mcc**2*p - 2*lrn*p + mcc**2*n + p)/(lrn**2*mcc**2*p**2 + lrn**2*n*p + 2*lrn*mcc**2*n*p - 2*lrn*n*p + mcc**2*n**2 + n*p)
    tn = mcc**2*n*(lrn*n*p + lrn*p**2 + n**2 + n*p)/(lrn**2*mcc**2*p**2 + lrn**2*n*p + 2*lrn*mcc**2*n*p - 2*lrn*n*p + mcc**2*n**2 + n*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_lrn_mcc(*, lrn, mcc, p, n):
  """
  Solution of for the lrn - mcc pair

  Args:
    lrn (int/float/Interval): the lrn score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_lrn_mcc_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_lrn_mcc_1(lrn=lrn, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_lrn_ji(*, lrn, ji, p, n):
  """
  Solution of for the lrn - ji pair

  Args:
    lrn (int/float/Interval): the lrn score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (ji*lrn*n*p + ji*lrn*p**2 - ji*n*p)/(-ji*n + lrn*p)
    tn = (-ji*n**2 - ji*n*p + n*p)/(-ji*n + lrn*p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def solve_lrn_ba(*, lrn, ba, p, n):
  """
  Solution of for the lrn - ba pair

  Args:
    lrn (int/float/Interval): the lrn score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (2.0*ba*lrn*p - p)/(lrn - 1.0)
    tn = (-2.0*ba*n + n)/(lrn - 1.0)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

def _solve_mk_dor_0(*, p):
  """
  Solution of for the mk - dor pair

  Args:
    mk (int/float/Interval): the mk score
    dor (int/float/Interval): the dor score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_dor_1(*, n):
  """
  Solution of for the mk - dor pair

  Args:
    mk (int/float/Interval): the mk score
    dor (int/float/Interval): the dor score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_dor_2(*, mk, dor, p, n):
  """
  Solution of for the mk - dor pair

  Args:
    mk (int/float/Interval): the mk score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor**2*mk*n + 2*dor**2*mk*p - dor**2*n - 2*dor*mk*p + 2*dor*n - mk*n + n*sqrt(dor**4*mk**2 - 2*dor**4*mk + dor**4 - 4*dor**3*mk**2 + 4*dor**3*mk - 4*dor**3 + 6*dor**2*mk**2 + 6*dor**2 - 4*dor*mk**2 - 4*dor*mk - 4*dor + mk**2 + 2*mk + 1) - n)/(2*mk*(dor**2 - 2*dor + 1))
    tn = (2*dor**2*mk*n + dor**2*mk*p - dor**2*p - 2*dor*mk*n + 2*dor*p - mk*p - p*sqrt(dor**4*mk**2 - 2*dor**4*mk + dor**4 - 4*dor**3*mk**2 + 4*dor**3*mk - 4*dor**3 + 6*dor**2*mk**2 + 6*dor**2 - 4*dor*mk**2 - 4*dor*mk - 4*dor + mk**2 + 2*mk + 1) - p)/(2*mk*(dor**2 - 2*dor + 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_dor_3(*, mk, dor, p, n):
  """
  Solution of for the mk - dor pair

  Args:
    mk (int/float/Interval): the mk score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor**2*mk*n + 2*dor**2*mk*p - dor**2*n - 2*dor*mk*p + 2*dor*n - mk*n - n*sqrt(dor**4*mk**2 - 2*dor**4*mk + dor**4 - 4*dor**3*mk**2 + 4*dor**3*mk - 4*dor**3 + 6*dor**2*mk**2 + 6*dor**2 - 4*dor*mk**2 - 4*dor*mk - 4*dor + mk**2 + 2*mk + 1) - n)/(2*mk*(dor**2 - 2*dor + 1))
    tn = (2*dor**2*mk*n + dor**2*mk*p - dor**2*p - 2*dor*mk*n + 2*dor*p - mk*p + p*sqrt(dor**4*mk**2 - 2*dor**4*mk + dor**4 - 4*dor**3*mk**2 + 4*dor**3*mk - 4*dor**3 + 6*dor**2*mk**2 + 6*dor**2 - 4*dor*mk**2 - 4*dor*mk - 4*dor + mk**2 + 2*mk + 1) - p)/(2*mk*(dor**2 - 2*dor + 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_mk_dor(*, mk, dor, p, n):
  """
  Solution of for the mk - dor pair

  Args:
    mk (int/float/Interval): the mk score
    dor (int/float/Interval): the dor score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_mk_dor_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_dor_1(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_dor_2(mk=mk, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_dor_3(mk=mk, dor=dor, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_mk_mcc_0(*, mk, p, n):
  """
  Solution of for the mk - mcc pair

  Args:
    mk (int/float/Interval): the mk score
    mcc (int/float/Interval): the mcc score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = (mk*n + mk*p - p + sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 - 2*mk*n*p - 2*mk*p**2 + p**2))/(2*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_mcc_1(*, mk, p, n):
  """
  Solution of for the mk - mcc pair

  Args:
    mk (int/float/Interval): the mk score
    mcc (int/float/Interval): the mcc score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = (mk*n + mk*p - p - sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 - 2*mk*n*p - 2*mk*p**2 + p**2))/(2*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_mcc_2(*, mk, p, n):
  """
  Solution of for the mk - mcc pair

  Args:
    mk (int/float/Interval): the mk score
    mcc (int/float/Interval): the mcc score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = (mk*n - mk*p - p + sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(2*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_mcc_3(*, mk, p, n):
  """
  Solution of for the mk - mcc pair

  Args:
    mk (int/float/Interval): the mk score
    mcc (int/float/Interval): the mcc score
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = (mk*n - mk*p - p - sqrt(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(2*mk)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_mcc_4(*, mk, mcc, p, n):
  """
  Solution of for the mk - mcc pair

  Args:
    mk (int/float/Interval): the mk score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(2*mcc**2*n + mk*n + mk*p + sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2))/(2*mk*(n + p))
    tn = (p*(2*mcc**2*n + mk*n + mk*p + sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) + sqrt((-2*n*p*(2*mcc**2*n + mk*n + mk*p + sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) - 2*p**2*(2*mcc**2*n + mk*n + mk*p + sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) + (n + p)*(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(n + p))*(n + p) + (n + p)*(mk*n - mk*p - p))/(2*mk*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_mcc_5(*, mk, mcc, p, n):
  """
  Solution of for the mk - mcc pair

  Args:
    mk (int/float/Interval): the mk score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(2*mcc**2*n + mk*n + mk*p + sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2))/(2*mk*(n + p))
    tn = (p*(2*mcc**2*n + mk*n + mk*p + sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) - sqrt((-2*n*p*(2*mcc**2*n + mk*n + mk*p + sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) - 2*p**2*(2*mcc**2*n + mk*n + mk*p + sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) + (n + p)*(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(n + p))*(n + p) + (n + p)*(mk*n - mk*p - p))/(2*mk*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_mcc_6(*, mk, mcc, p, n):
  """
  Solution of for the mk - mcc pair

  Args:
    mk (int/float/Interval): the mk score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(2*mcc**2*n + mk*n + mk*p - sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2))/(2*mk*(n + p))
    tn = (p*(2*mcc**2*n + mk*n + mk*p - sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) + sqrt((-2*n*p*(2*mcc**2*n + mk*n + mk*p - sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) - 2*p**2*(2*mcc**2*n + mk*n + mk*p - sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) + (n + p)*(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(n + p))*(n + p) + (n + p)*(mk*n - mk*p - p))/(2*mk*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_mcc_7(*, mk, mcc, p, n):
  """
  Solution of for the mk - mcc pair

  Args:
    mk (int/float/Interval): the mk score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(2*mcc**2*n + mk*n + mk*p - sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2))/(2*mk*(n + p))
    tn = (p*(2*mcc**2*n + mk*n + mk*p - sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) - sqrt((-2*n*p*(2*mcc**2*n + mk*n + mk*p - sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) - 2*p**2*(2*mcc**2*n + mk*n + mk*p - sqrt(-4*mcc**2*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2)) + (n + p)*(mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(n + p))*(n + p) + (n + p)*(mk*n - mk*p - p))/(2*mk*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_mk_mcc(*, mk, mcc, p, n):
  """
  Solution of for the mk - mcc pair

  Args:
    mk (int/float/Interval): the mk score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_mk_mcc_0(mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_mcc_1(mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_mcc_2(mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_mcc_3(mk=mk, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_mcc_4(mk=mk, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_mcc_5(mk=mk, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_mcc_6(mk=mk, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_mcc_7(mk=mk, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_mk_ji_0(*, mk, ji, p, n):
  """
  Solution of for the mk - ji pair

  Args:
    mk (int/float/Interval): the mk score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = ji*(ji*mk*n + 3*ji*mk*p - ji*n + mk*n + 3*mk*p + p + sqrt(ji**2*mk**2*n**2 + 2*ji**2*mk**2*n*p + ji**2*mk**2*p**2 - 2*ji**2*mk*n**2 - 6*ji**2*mk*n*p - 4*ji**2*mk*p**2 + ji**2*n**2 + 2*ji*mk**2*n**2 + 4*ji*mk**2*n*p + 2*ji*mk**2*p**2 - 2*ji*mk*n**2 - 4*ji*mk*n*p - 2*ji*mk*p**2 - 2*ji*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(2*mk*(ji**2 + 2*ji + 1))
    tn = (2*ji**2*mk*n + 2*ji**2*mk*p + 3*ji*mk*n + ji*mk*p + ji*n + mk*n - mk*p - p - sqrt(ji**2*mk**2*n**2 + 2*ji**2*mk**2*n*p + ji**2*mk**2*p**2 - 2*ji**2*mk*n**2 - 6*ji**2*mk*n*p - 4*ji**2*mk*p**2 + ji**2*n**2 + 2*ji*mk**2*n**2 + 4*ji*mk**2*n*p + 2*ji*mk**2*p**2 - 2*ji*mk*n**2 - 4*ji*mk*n*p - 2*ji*mk*p**2 - 2*ji*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(2*mk*(ji**2 + 2*ji + 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_ji_1(*, mk, ji, p, n):
  """
  Solution of for the mk - ji pair

  Args:
    mk (int/float/Interval): the mk score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = ji*(ji*mk*n + 3*ji*mk*p - ji*n + mk*n + 3*mk*p + p - sqrt(ji**2*mk**2*n**2 + 2*ji**2*mk**2*n*p + ji**2*mk**2*p**2 - 2*ji**2*mk*n**2 - 6*ji**2*mk*n*p - 4*ji**2*mk*p**2 + ji**2*n**2 + 2*ji*mk**2*n**2 + 4*ji*mk**2*n*p + 2*ji*mk**2*p**2 - 2*ji*mk*n**2 - 4*ji*mk*n*p - 2*ji*mk*p**2 - 2*ji*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(2*mk*(ji**2 + 2*ji + 1))
    tn = (2*ji**2*mk*n + 2*ji**2*mk*p + 3*ji*mk*n + ji*mk*p + ji*n + mk*n - mk*p - p + sqrt(ji**2*mk**2*n**2 + 2*ji**2*mk**2*n*p + ji**2*mk**2*p**2 - 2*ji**2*mk*n**2 - 6*ji**2*mk*n*p - 4*ji**2*mk*p**2 + ji**2*n**2 + 2*ji*mk**2*n**2 + 4*ji*mk**2*n*p + 2*ji*mk**2*p**2 - 2*ji*mk*n**2 - 4*ji*mk*n*p - 2*ji*mk*p**2 - 2*ji*n*p + mk**2*n**2 + 2*mk**2*n*p + mk**2*p**2 + 2*mk*n*p + 2*mk*p**2 + p**2))/(2*mk*(ji**2 + 2*ji + 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_mk_ji(*, mk, ji, p, n):
  """
  Solution of for the mk - ji pair

  Args:
    mk (int/float/Interval): the mk score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_mk_ji_0(mk=mk, ji=ji, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_ji_1(mk=mk, ji=ji, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_mk_ba_0(*, mk, ba, p, n):
  """
  Solution of for the mk - ba pair

  Args:
    mk (int/float/Interval): the mk score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0.5*p*(4.0*ba*mk*n - mk*n + mk*p + sqrt(mk*(-8.0*ba*n*p + mk*n**2 + 2.0*mk*n*p + mk*p**2 + 4.0*n*p)))/(mk*(n + p))
    tn = 0.5*n*(4.0*ba*mk*p + mk*n - mk*p - sqrt(mk*(-8.0*ba*n*p + mk*n**2 + 2.0*mk*n*p + mk*p**2 + 4.0*n*p)))/(mk*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mk_ba_1(*, mk, ba, p, n):
  """
  Solution of for the mk - ba pair

  Args:
    mk (int/float/Interval): the mk score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0.5*p*(4.0*ba*mk*n - mk*n + mk*p - sqrt(mk*(-8.0*ba*n*p + mk*n**2 + 2.0*mk*n*p + mk*p**2 + 4.0*n*p)))/(mk*(n + p))
    tn = 0.5*n*(4.0*ba*mk*p + mk*n - mk*p + sqrt(mk*(-8.0*ba*n*p + mk*n**2 + 2.0*mk*n*p + mk*p**2 + 4.0*n*p)))/(mk*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_mk_ba(*, mk, ba, p, n):
  """
  Solution of for the mk - ba pair

  Args:
    mk (int/float/Interval): the mk score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_mk_ba_0(mk=mk, ba=ba, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mk_ba_1(mk=mk, ba=ba, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_dor_mcc_0(*, p):
  """
  Solution of for the dor - mcc pair

  Args:
    dor (int/float/Interval): the dor score
    mcc (int/float/Interval): the mcc score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p
    tn = 0
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_dor_mcc_1(*, n):
  """
  Solution of for the dor - mcc pair

  Args:
    dor (int/float/Interval): the dor score
    mcc (int/float/Interval): the mcc score

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0
    tn = n
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_dor_mcc_2(*, dor, mcc, p, n):
  """
  Solution of for the dor - mcc pair

  Args:
    dor (int/float/Interval): the dor score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor*mcc**2*n*p + 2*dor*mcc**2*p**2 + dor*n*p + mcc**2*n*p - n*p + sqrt(n*p*(dor**2*mcc**4*n*p - 2*dor**2*mcc**2*n*p + dor**2*n*p - 2*dor*mcc**4*n*p - 4*dor*mcc**2*n**2 - 4*dor*mcc**2*n*p - 4*dor*mcc**2*p**2 - 2*dor*n*p + mcc**4*n*p - 2*mcc**2*n*p + n*p)))/(2*(dor*mcc**2*p + dor*n - mcc**2*p - n))
    tn = dor*n*(dor*mcc**2*n*p - dor*n*p + mcc**2*n*p + 2*mcc**2*p**2 + n*p + sqrt(n*p*(dor**2*mcc**4*n*p - 2*dor**2*mcc**2*n*p + dor**2*n*p - 2*dor*mcc**4*n*p - 4*dor*mcc**2*n**2 - 4*dor*mcc**2*n*p - 4*dor*mcc**2*p**2 - 2*dor*n*p + mcc**4*n*p - 2*mcc**2*n*p + n*p)))/(dor**2*mcc**2*n*p - dor**2*n*p + dor*sqrt(n*p*(dor**2*mcc**4*n*p - 2*dor**2*mcc**2*n*p + dor**2*n*p - 2*dor*mcc**4*n*p - 4*dor*mcc**2*n**2 - 4*dor*mcc**2*n*p - 4*dor*mcc**2*p**2 - 2*dor*n*p + mcc**4*n*p - 2*mcc**2*n*p + n*p)) - mcc**2*n*p + n*p - sqrt(n*p*(dor**2*mcc**4*n*p - 2*dor**2*mcc**2*n*p + dor**2*n*p - 2*dor*mcc**4*n*p - 4*dor*mcc**2*n**2 - 4*dor*mcc**2*n*p - 4*dor*mcc**2*p**2 - 2*dor*n*p + mcc**4*n*p - 2*mcc**2*n*p + n*p)))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_dor_mcc_3(*, dor, mcc, p, n):
  """
  Solution of for the dor - mcc pair

  Args:
    dor (int/float/Interval): the dor score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor*mcc**2*n*p + 2*dor*mcc**2*p**2 + dor*n*p + mcc**2*n*p - n*p - sqrt(n*p*(dor**2*mcc**4*n*p - 2*dor**2*mcc**2*n*p + dor**2*n*p - 2*dor*mcc**4*n*p - 4*dor*mcc**2*n**2 - 4*dor*mcc**2*n*p - 4*dor*mcc**2*p**2 - 2*dor*n*p + mcc**4*n*p - 2*mcc**2*n*p + n*p)))/(2*(dor*mcc**2*p + dor*n - mcc**2*p - n))
    tn = dor*n*(dor*mcc**2*n*p - dor*n*p + mcc**2*n*p + 2*mcc**2*p**2 + n*p - sqrt(n*p*(dor**2*mcc**4*n*p - 2*dor**2*mcc**2*n*p + dor**2*n*p - 2*dor*mcc**4*n*p - 4*dor*mcc**2*n**2 - 4*dor*mcc**2*n*p - 4*dor*mcc**2*p**2 - 2*dor*n*p + mcc**4*n*p - 2*mcc**2*n*p + n*p)))/(dor**2*mcc**2*n*p - dor**2*n*p - dor*sqrt(n*p*(dor**2*mcc**4*n*p - 2*dor**2*mcc**2*n*p + dor**2*n*p - 2*dor*mcc**4*n*p - 4*dor*mcc**2*n**2 - 4*dor*mcc**2*n*p - 4*dor*mcc**2*p**2 - 2*dor*n*p + mcc**4*n*p - 2*mcc**2*n*p + n*p)) - mcc**2*n*p + n*p + sqrt(n*p*(dor**2*mcc**4*n*p - 2*dor**2*mcc**2*n*p + dor**2*n*p - 2*dor*mcc**4*n*p - 4*dor*mcc**2*n**2 - 4*dor*mcc**2*n*p - 4*dor*mcc**2*p**2 - 2*dor*n*p + mcc**4*n*p - 2*mcc**2*n*p + n*p)))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_dor_mcc(*, dor, mcc, p, n):
  """
  Solution of for the dor - mcc pair

  Args:
    dor (int/float/Interval): the dor score
    mcc (int/float/Interval): the mcc score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_dor_mcc_0(p=p)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_dor_mcc_1(n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_dor_mcc_2(dor=dor, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_dor_mcc_3(dor=dor, mcc=mcc, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_dor_ji_0(*, dor, ji, p, n):
  """
  Solution of for the dor - ji pair

  Args:
    dor (int/float/Interval): the dor score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor*ji*p + dor*p - ji*n - ji*p + sqrt(dor**2*ji**2*p**2 - 2*dor**2*ji*p**2 + dor**2*p**2 - 2*dor*ji**2*n*p - 2*dor*ji**2*p**2 - 2*dor*ji*n*p + 2*dor*ji*p**2 + ji**2*n**2 + 2*ji**2*n*p + ji**2*p**2))/(2*(dor - 1))
    tn = (2*dor*ji*n + dor*ji*p - dor*p - ji*n - ji*p - sqrt(dor**2*ji**2*p**2 - 2*dor**2*ji*p**2 + dor**2*p**2 - 2*dor*ji**2*n*p - 2*dor*ji**2*p**2 - 2*dor*ji*n*p + 2*dor*ji*p**2 + ji**2*n**2 + 2*ji**2*n*p + ji**2*p**2))/(2*ji*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_dor_ji_1(*, dor, ji, p, n):
  """
  Solution of for the dor - ji pair

  Args:
    dor (int/float/Interval): the dor score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (dor*ji*p + dor*p - ji*n - ji*p - sqrt(dor**2*ji**2*p**2 - 2*dor**2*ji*p**2 + dor**2*p**2 - 2*dor*ji**2*n*p - 2*dor*ji**2*p**2 - 2*dor*ji*n*p + 2*dor*ji*p**2 + ji**2*n**2 + 2*ji**2*n*p + ji**2*p**2))/(2*(dor - 1))
    tn = (2*dor*ji*n + dor*ji*p - dor*p - ji*n - ji*p + sqrt(dor**2*ji**2*p**2 - 2*dor**2*ji*p**2 + dor**2*p**2 - 2*dor*ji**2*n*p - 2*dor*ji**2*p**2 - 2*dor*ji*n*p + 2*dor*ji*p**2 + ji**2*n**2 + 2*ji**2*n*p + ji**2*p**2))/(2*ji*(dor - 1))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_dor_ji(*, dor, ji, p, n):
  """
  Solution of for the dor - ji pair

  Args:
    dor (int/float/Interval): the dor score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_dor_ji_0(dor=dor, ji=ji, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_dor_ji_1(dor=dor, ji=ji, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_dor_ba_0(*, dor, ba, p, n):
  """
  Solution of for the dor - ba pair

  Args:
    dor (int/float/Interval): the dor score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(ba*dor - ba + 1.4142135623731*sqrt(0.5*ba**2*dor**2 - ba**2*dor + 0.5*ba**2 - ba*dor**2 + ba*dor + 0.5*dor**2 - 0.5*dor))/(dor - 1.0)
    tn = n*(ba*dor - ba - 1.4142135623731*sqrt(0.5*ba**2*dor**2 - ba**2*dor + 0.5*ba**2 - ba*dor**2 + ba*dor + 0.5*dor**2 - 0.5*dor))/(dor - 1.0)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_dor_ba_1(*, dor, ba, p, n):
  """
  Solution of for the dor - ba pair

  Args:
    dor (int/float/Interval): the dor score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = p*(ba*dor - ba - 1.4142135623731*sqrt(0.5*ba**2*dor**2 - ba**2*dor + 0.5*ba**2 - ba*dor**2 + ba*dor + 0.5*dor**2 - 0.5*dor))/(dor - 1.0)
    tn = n*(ba*dor - ba + 1.4142135623731*sqrt(0.5*ba**2*dor**2 - ba**2*dor + 0.5*ba**2 - ba*dor**2 + ba*dor + 0.5*dor**2 - 0.5*dor))/(dor - 1.0)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_dor_ba(*, dor, ba, p, n):
  """
  Solution of for the dor - ba pair

  Args:
    dor (int/float/Interval): the dor score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_dor_ba_0(dor=dor, ba=ba, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_dor_ba_1(dor=dor, ba=ba, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_mcc_ji_0(*, mcc, ji, p, n):
  """
  Solution of for the mcc - ji pair

  Args:
    mcc (int/float/Interval): the mcc score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = ji*p*(ji*mcc**2*n**2 + 3*ji*mcc**2*n*p - 2*ji*n*p + mcc**2*n**2 + 3*mcc**2*n*p - mcc*sqrt(n*(ji**2*mcc**2*n - 4*ji**2*n - 4*ji**2*p + 2*ji*mcc**2*n + 4*ji*p + mcc**2*n))*(n + p) + 2*p**2)/(2*(ji**2*mcc**2*n*p + ji**2*n**2 + 2*ji*mcc**2*n*p - 2*ji*n*p + mcc**2*n*p + p**2))
    tn = (p*(-ji**2*mcc**2*n**2 - ji**2*mcc**2*n*p + 2*ji**2*n**2 + 2*ji**2*n*p - ji*mcc**2*n**2 + ji*mcc**2*n*p + ji*mcc*sqrt(n*(ji**2*mcc**2*n - 4*ji**2*n - 4*ji**2*p + 2*ji*mcc**2*n + 4*ji*p + mcc**2*n))*(n + p) - 4*ji*n*p - 2*ji*p**2 + 2*mcc**2*n*p + 2*p**2)/2 + (ji*n + ji*p - p)*(ji**2*mcc**2*n*p + ji**2*n**2 + 2*ji*mcc**2*n*p - 2*ji*n*p + mcc**2*n*p + p**2))/(ji*(ji**2*mcc**2*n*p + ji**2*n**2 + 2*ji*mcc**2*n*p - 2*ji*n*p + mcc**2*n*p + p**2))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mcc_ji_1(*, mcc, ji, p, n):
  """
  Solution of for the mcc - ji pair

  Args:
    mcc (int/float/Interval): the mcc score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = ji*p*(ji*mcc**2*n**2 + 3*ji*mcc**2*n*p - 2*ji*n*p + mcc**2*n**2 + 3*mcc**2*n*p + mcc*sqrt(n*(ji**2*mcc**2*n - 4*ji**2*n - 4*ji**2*p + 2*ji*mcc**2*n + 4*ji*p + mcc**2*n))*(n + p) + 2*p**2)/(2*(ji**2*mcc**2*n*p + ji**2*n**2 + 2*ji*mcc**2*n*p - 2*ji*n*p + mcc**2*n*p + p**2))
    tn = (-p*(ji**2*mcc**2*n**2 + ji**2*mcc**2*n*p - 2*ji**2*n**2 - 2*ji**2*n*p + ji*mcc**2*n**2 - ji*mcc**2*n*p + ji*mcc*sqrt(n*(ji**2*mcc**2*n - 4*ji**2*n - 4*ji**2*p + 2*ji*mcc**2*n + 4*ji*p + mcc**2*n))*(n + p) + 4*ji*n*p + 2*ji*p**2 - 2*mcc**2*n*p - 2*p**2)/2 + (ji*n + ji*p - p)*(ji**2*mcc**2*n*p + ji**2*n**2 + 2*ji*mcc**2*n*p - 2*ji*n*p + mcc**2*n*p + p**2))/(ji*(ji**2*mcc**2*n*p + ji**2*n**2 + 2*ji*mcc**2*n*p - 2*ji*n*p + mcc**2*n*p + p**2))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_mcc_ji(*, mcc, ji, p, n):
  """
  Solution of for the mcc - ji pair

  Args:
    mcc (int/float/Interval): the mcc score
    ji (int/float/Interval): the ji score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_mcc_ji_0(mcc=mcc, ji=ji, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mcc_ji_1(mcc=mcc, ji=ji, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def _solve_mcc_ba_0(*, mcc, ba, p, n):
  """
  Solution of for the mcc - ba pair

  Args:
    mcc (int/float/Interval): the mcc score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0.5*(4.0*ba*n**2*p - 3.0*n**2*p - n*p**2 + 2.0*n*p*(n + p) + sqrt(n**2*p**2*(mcc**2*(n**2 + 2.0*n*p + p**2) - 16.0*n*p*(ba - 0.5)**2)/mcc**2))/(n*(n + p))
    tn = 0.5*(-4.0*ba*n**2*p + 3.0*n**2*p + n*p**2 + 2.0*n*p*(2.0*ba - 1.0)*(n + p) - sqrt(n**2*p**2*(mcc**2*(n**2 + 2.0*n*p + p**2) - 16.0*n*p*(ba - 0.5)**2)/mcc**2))/(p*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def _solve_mcc_ba_1(*, mcc, ba, p, n):
  """
  Solution of for the mcc - ba pair

  Args:
    mcc (int/float/Interval): the mcc score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = 0.5*(4.0*ba*n**2*p - 3.0*n**2*p - n*p**2 + 2.0*n*p*(n + p) - sqrt(n**2*p**2*(mcc**2*(n**2 + 2.0*n*p + p**2) - 16.0*n*p*(ba - 0.5)**2)/mcc**2))/(n*(n + p))
    tn = 0.5*(-4.0*ba*n**2*p + 3.0*n**2*p + n*p**2 + 2.0*n*p*(2.0*ba - 1.0)*(n + p) + sqrt(n**2*p**2*(mcc**2*(n**2 + 2.0*n*p + p**2) - 16.0*n*p*(ba - 0.5)**2)/mcc**2))/(p*(n + p))
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return tp, tn

def solve_mcc_ba(*, mcc, ba, p, n):
  """
  Solution of for the mcc - ba pair

  Args:
    mcc (int/float/Interval): the mcc score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  tps = []
  tns = []
  tp, tn = _solve_mcc_ba_0(mcc=mcc, ba=ba, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  tp, tn = _solve_mcc_ba_1(mcc=mcc, ba=ba, p=p, n=n)
  tps.append(tp)
  tns.append(tn)
  return reduce_solutions(tps, tns, p, n)

def solve_ji_ba(*, ji, ba, p, n):
  """
  Solution of for the ji - ba pair

  Args:
    ji (int/float/Interval): the ji score
    ba (int/float/Interval): the ba score
    p (int/float/Interval): the p value
    n (int/float/Interval): the n value

  Returns:
    float/Interval, float/Interval: the tp and tn solutions
  """
  try:
    tp = (-2.0*ba*ji*n*p + ji*n*p + ji*p**2)/(-ji*n + p)
    tn = (2.0*ba*n*p - ji*n**2 - ji*n*p)/(-ji*n + p)
  except ZeroDivisionError:
    tp = np.nan
    tn = np.nan
  return reduce_solutions([tp], [tn], p, n)

